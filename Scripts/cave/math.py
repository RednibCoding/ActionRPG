"""
use: from __future__ import annotations
to basically forward declare types

for example: 

class Vector2:
	def copy(self) -> Vector2: ... # usage of Vector2 here will give a linting error

"""


# Python Stub File for the Cave Engine's MATH API
# The code here is available at cave.math. submodule

# Basically like forward declarations in c/c++
from __future__ import annotations


def clamp(x: float, minVal: float, maxVal: float) -> float: ...

def min(x: float, y: float) -> float: ...
def max(x: float, y: float) -> float: ...

def sin(value: float) -> float: ...
def cos(value: float) -> float: ...
def tan(value: float) -> float: ...

def asin(value: float) -> float: ...
def acos(value: float) -> float: ...
def atan(value: float) -> float: ...

def abs(value: float) -> float: ...
def ceil(value: float) -> float: ...
def floor(value: float) -> float: ...
def round(value: float) -> float: ...

def pow(x: float, y: float) -> float: ...

# Regular Lerpings:
def lerp(a: float, b: float, value: float) -> float: ...
def lerp(a: Vector2, b: Vector2, value: float) -> Vector2: ...
def lerp(a: Vector3, b: Vector3, value: float) -> Vector3: ...
def lerp(a: Vector4, b: Vector4, value: float) -> Vector4: ...
def lerp(a: int, b: int, value: float) -> int: ...
def lerp(a: IntVector2, b: IntVector2, value: float) -> IntVector2: ...
def lerp(a: IntVector3, b: IntVector3, value: float) -> IntVector3: ...
def lerp(a: IntVector4, b: IntVector4, value: float) -> IntVector4: ...

# Ease Lerpings:
def lerpEase(a: float, b: float, value: float) -> float: ...
def lerpEase(a: Vector2, b: Vector2, value: float) -> Vector2: ...
def lerpEase(a: Vector3, b: Vector3, value: float) -> Vector3: ...
def lerpEase(a: Vector4, b: Vector4, value: float) -> Vector4: ...
def lerpEase(a: int, b: int, value: float) -> int: ...
def lerpEase(a: IntVector2, b: IntVector2, value: float) -> IntVector2: ...
def lerpEase(a: IntVector3, b: IntVector3, value: float) -> IntVector3: ...
def lerpEase(a: IntVector4, b: IntVector4, value: float) -> IntVector4: ...

# Euler Lerpings:
def lerpEuler(a: Vector3, b: Vector3, value: float) -> Vector3: ...

# Quadric Lerpings:
def lerpQuadric(a: float, b: float, c: float, value: float) -> float: ...
def lerpQuadric(a: Vector2, b: Vector2, c: Vector2, value: float) -> Vector2: ...
def lerpQuadric(a: Vector3, b: Vector3, c: Vector3, value: float) -> Vector3: ...
def lerpQuadric(a: Vector4, b: Vector4, c: Vector4, value: float) -> Vector4: ...
def lerpQuadric(a: int, b: int, c: int, value: float) -> int: ...
def lerpQuadric(a: IntVector2, b: IntVector2, c: IntVector2, value: float) -> IntVector2: ...
def lerpQuadric(a: IntVector3, b: IntVector3, c: IntVector3, value: float) -> IntVector3: ...
def lerpQuadric(a: IntVector4, b: IntVector4, c: IntVector4, value: float) -> IntVector4: ...

# Quaternion Lerpings:
def lerp(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...
def lerpEase(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...
def slerp(a: Quaternion, b: Quaternion, value: float) -> Quaternion: ...

def normalizeEulerAngle(angle: float) -> float: ... # Returns the angle in range [0, 360]
def clampEulerAngle(angle: float, fromMin: float, fromMax) -> float: ... # Clamps the euler angle, works with negative eulers too!

def mapRange(value: float, fromMin: float, fromMax: float, toMin: float, toMax: float) -> float: ...

def dot(x: Vector2, y: Vector2) -> float: ...
def dot(x: Vector3, y: Vector3) -> float: ...
def dot(x: Vector4, y: Vector4) -> float: ...

def inverse(q: Quaternion) -> Quaternion: ...
def inverse(m: Matrix4) -> Matrix4: ...

def project(vec: Vector2, other: Vector2) -> Vector2: ...
def project(vec: Vector3, other: Vector3) -> Vector3: ...
def project(vec: Vector4, other: Vector4) -> Vector4: ...

# Intersections:
def intersectLineSphere(lineP1: Vector3, lineP2: Vector3, sphereCenter: Vector3, sphereRadius: float) -> list: ... # Returns a list of tuples containing the intersection positions and normals!
def intersectLineTriangle(lineP1: Vector3, lineP2: Vector3, p1: Vector3, p2: Vector3, p3: Vector3) -> tuple[Vector3, None]: ...



# Class reference:

class Matrix3:
	def __init__(self): ...

class Matrix4:
	def __init__(self): ...

class IntVector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : int = 0
	y : int = 0

	s : int = 0
	t : int = 0

	u : int = 0
	v : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int): ...
	def __init__(self, other: IntVector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: IntVector2) -> bool: ...
	def __iadd__(self, other: IntVector2) -> IntVector2: ...
	def __isub__(self, other: IntVector2) -> IntVector2: ...
	def __imul__(self, scalar: float) -> IntVector2: ...
	def __idiv__(self, scalar: float) -> IntVector2: ...
	def __add__(self, other: IntVector2) -> IntVector2: ...
	def __sub__(self, other: IntVector2) -> IntVector2: ...
	def __mul__(self, scalar: float) -> IntVector2: ...
	def __truediv__(self, scalar: float) -> IntVector2: ...

class IntVector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : int = 0
	y : int = 0
	z : int = 0

	r : int = 0
	g : int = 0
	b : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int, z: int): ...
	def __init__(self, other: IntVector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: IntVector3) -> bool: ...
	def __iadd__(self, other: IntVector3) -> IntVector3: ...
	def __isub__(self, other: IntVector3) -> IntVector3: ...
	def __imul__(self, scalar: float) -> IntVector3: ...
	def __idiv__(self, scalar: float) -> IntVector3: ...
	def __add__(self, other: IntVector3) -> IntVector3: ...
	def __sub__(self, other: IntVector3) -> IntVector3: ...
	def __mul__(self, scalar: float) -> IntVector3: ...
	def __truediv__(self, scalar: float) -> IntVector3: ...

class IntVector4:
	# TODO: implement
	pass

class Vector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : float = 0
	y : float = 0

	s : float = 0
	t : float = 0

	u : float = 0
	v : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float): ...
	def __init__(self, other: Vector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector2: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector2: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector2, value: float) -> Vector2: ...
	def lerpEase(self, other: Vector2, value: float) -> Vector2: ...
	def dot(self, other: Vector2) -> Vector2: ...
	def project(self, intoOther: Vector2) -> Vector2: ...
	
	def __neg__(self) -> Vector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector2) -> bool: ...
	def __iadd__(self, other: Vector2) -> Vector2: ...
	def __isub__(self, other: Vector2) -> Vector2: ...
	def __imul__(self, scalar: float) -> Vector2: ...
	def __idiv__(self, scalar: float) -> Vector2: ...
	def __add__(self, other: Vector2) -> Vector2: ...
	def __sub__(self, other: Vector2) -> Vector2: ...
	def __mul__(self, scalar: float) -> Vector2: ...
	def __truediv__(self, scalar: float) -> Vector2: ...

class Vector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0

	r : float = 0
	g : float = 0
	b : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float): ...
	def __init__(self, other: Vector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector3: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector3: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector3, value: float) -> Vector3: ...
	def lerpEase(self, other: Vector3, value: float) -> Vector3: ...
	def dot(self, other: Vector3) -> Vector3: ...
	def project(self, intoOther: Vector3) -> Vector3: ...
	
	def __neg__(self) -> Vector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector3) -> bool: ...
	def __iadd__(self, other: Vector3) -> Vector3: ...
	def __isub__(self, other: Vector3) -> Vector3: ...
	def __imul__(self, scalar: float) -> Vector3: ...
	def __idiv__(self, scalar: float) -> Vector3: ...
	def __add__(self, other: Vector3) -> Vector3: ...
	def __sub__(self, other: Vector3) -> Vector3: ...
	def __mul__(self, scalar: float) -> Vector3: ...
	def __truediv__(self, scalar: float) -> Vector3: ...

class Vector4:
	# [x,y,z,w] or [r,g,b,a] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	r : float = 0
	g : float = 0
	b : float = 0
	a : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Vector4): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector4: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector4: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector4, value: float) -> Vector4: ...
	def lerpEase(self, other: Vector4, value: float) -> Vector4: ...
	def dot(self, other: Vector4) -> Vector4: ...
	def project(self, intoOther: Vector4) -> Vector4: ...
	
	def __neg__(self) -> Vector4: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector4) -> bool: ...
	def __iadd__(self, other: Vector4) -> Vector4: ...
	def __isub__(self, other: Vector4) -> Vector4: ...
	def __imul__(self, scalar: float) -> Vector4: ...
	def __idiv__(self, scalar: float) -> Vector4: ...
	def __add__(self, other: Vector4) -> Vector4: ...
	def __sub__(self, other: Vector4) -> Vector4: ...
	def __mul__(self, scalar: float) -> Vector4: ...
	def __truediv__(self, scalar: float) -> Vector4: ...

class Quaternion:
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Quaternion): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Quaternion: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Quaternion: ...
	def length(self) -> float: ...

	def lerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def lerpEase(self, other: Quaternion, value: float) -> Quaternion: ...
	def slerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def inversed(self) -> Quaternion: ...
	
	def __neg__(self) -> Quaternion: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, +, -, *

	def __eq__(self, other: Quaternion) -> bool: ...
	def __iadd__(self, other: Quaternion) -> Quaternion: ...
	def __isub__(self, other: Quaternion) -> Quaternion: ...
	def __imul__(self, scalar: float) -> Quaternion: ...
	def __add__(self, other: Quaternion) -> Quaternion: ...
	def __sub__(self, other: Quaternion) -> Quaternion: ...
	def __mul__(self, scalar: float) -> Quaternion: ...

# Deprecated:
def normalized(vector: Vector3) -> Vector3: ...
def length(vector: Vector3) -> Vector3: ...