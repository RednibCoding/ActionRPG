from typing import List, Dict, Tuple, Any

# Engine Utils:

def getGlobalDict() -> dict: ... # This dictionary is persistent during the entire gameplay

def hasEditor() -> bool: ... # Returns True if cave is in Editor mode, False if it's a standalone game!
def isPlaying() -> bool: ... # Returns True if the game is currently being played in the editor. It's always true on standalone.

def getGamePath(localPath: str) -> str: ... # Returns the Game's current path + the localPath

def getDeltaTime() -> float: ...
def getFPS() -> float: ...

def getMousePosition(normalize: bool= False) -> Vector2: ...
def getMousePositionUI() -> Vector2: ... # This one takes the Editor UI into account and is always like the UI Elements!
def setMousePosition(x: int, y: int) -> None: ...

def getWindowSize() -> Vector2: ...

def quitGame() -> None: ...

def setScene(name: str) -> bool: ...
def getScene() -> Scene: ...
def getCurrentScene() -> Scene: ...
def restartCurrentScene() -> None: ...

def getEvents() -> Events: ...
def getWindow() -> Window: ...

def getScriptSource(scriptName: str) -> str: ...

def getEntityTemplate(name: str, markAsDirty: bool= False) -> EntityTemplate: ...
def getMesh(name: str, markAsDirty: bool= False) -> Mesh: ...

def playSound(name: str, volume: float = 1.0, loop: int = 0, startPaused: bool = False) -> AudioTrackInstance: ...

def makeImage(filePath: str, pixels: list[int], width: int, height: int) -> bool: ...

T = Any

class AssetHandler_T_(IAssetHandler):
	def __init__(self, name: str = ""): ...
	def makeWeakRef(asset: T) -> None: ...
	def makeLocalCopy() -> None: ...
	def makeLocalNew() -> None: ...

	def get(markAsDirty: bool = True) -> T: ...


# Math Classes:

class Matrix3:
	def __init__(self): ...

class Matrix4:
	def __init__(self): ...

class IntVector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : int = 0
	y : int = 0

	s : int = 0
	t : int = 0

	u : int = 0
	v : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int): ...
	def __init__(self, other: IntVector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: IntVector2) -> bool: ...
	def __iadd__(self, other: IntVector2) -> IntVector2: ...
	def __isub__(self, other: IntVector2) -> IntVector2: ...
	def __imul__(self, scalar: float) -> IntVector2: ...
	def __idiv__(self, scalar: float) -> IntVector2: ...
	def __add__(self, other: IntVector2) -> IntVector2: ...
	def __sub__(self, other: IntVector2) -> IntVector2: ...
	def __mul__(self, scalar: float) -> IntVector2: ...
	def __truediv__(self, scalar: float) -> IntVector2: ...

class IntVector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : int = 0
	y : int = 0
	z : int = 0

	r : int = 0
	g : int = 0
	b : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int, z: int): ...
	def __init__(self, other: IntVector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: IntVector3) -> bool: ...
	def __iadd__(self, other: IntVector3) -> IntVector3: ...
	def __isub__(self, other: IntVector3) -> IntVector3: ...
	def __imul__(self, scalar: float) -> IntVector3: ...
	def __idiv__(self, scalar: float) -> IntVector3: ...
	def __add__(self, other: IntVector3) -> IntVector3: ...
	def __sub__(self, other: IntVector3) -> IntVector3: ...
	def __mul__(self, scalar: float) -> IntVector3: ...
	def __truediv__(self, scalar: float) -> IntVector3: ...

class Vector2:
	# [x,y] or [s,t] or [u,v] are equivalents!
	x : float = 0
	y : float = 0

	s : float = 0
	t : float = 0

	u : float = 0
	v : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float): ...
	def __init__(self, other: Vector2): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector2: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector2: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector2, value: float) -> Vector2: ...
	def lerpEase(self, other: Vector2, value: float) -> Vector2: ...
	def dot(self, other: Vector2) -> Vector2: ...
	def project(self, intoOther: Vector2) -> Vector2: ...
	
	def __neg__(self) -> Vector2: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector2) -> bool: ...
	def __iadd__(self, other: Vector2) -> Vector2: ...
	def __isub__(self, other: Vector2) -> Vector2: ...
	def __imul__(self, scalar: float) -> Vector2: ...
	def __idiv__(self, scalar: float) -> Vector2: ...
	def __add__(self, other: Vector2) -> Vector2: ...
	def __sub__(self, other: Vector2) -> Vector2: ...
	def __mul__(self, scalar: float) -> Vector2: ...
	def __truediv__(self, scalar: float) -> Vector2: ...

class Vector3:
	# [x,y,z] or [r,g,b] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0

	r : float = 0
	g : float = 0
	b : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float): ...
	def __init__(self, other: Vector3): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector3: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector3: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector3, value: float) -> Vector3: ...
	def lerpEase(self, other: Vector3, value: float) -> Vector3: ...
	def dot(self, other: Vector3) -> Vector3: ...
	def project(self, intoOther: Vector3) -> Vector3: ...
	
	def __neg__(self) -> Vector3: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector3) -> bool: ...
	def __iadd__(self, other: Vector3) -> Vector3: ...
	def __isub__(self, other: Vector3) -> Vector3: ...
	def __imul__(self, scalar: float) -> Vector3: ...
	def __idiv__(self, scalar: float) -> Vector3: ...
	def __add__(self, other: Vector3) -> Vector3: ...
	def __sub__(self, other: Vector3) -> Vector3: ...
	def __mul__(self, scalar: float) -> Vector3: ...
	def __truediv__(self, scalar: float) -> Vector3: ...

class Vector4:
	# [x,y,z,w] or [r,g,b,a] are equivalents!
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	r : float = 0
	g : float = 0
	b : float = 0
	a : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Vector4): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Vector4: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Vector4: ...
	def length(self) -> float: ...

	def lerp(self, other: Vector4, value: float) -> Vector4: ...
	def lerpEase(self, other: Vector4, value: float) -> Vector4: ...
	def dot(self, other: Vector4) -> Vector4: ...
	def project(self, intoOther: Vector4) -> Vector4: ...
	
	def __neg__(self) -> Vector4: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, /=, +, -, *, /

	def __eq__(self, other: Vector4) -> bool: ...
	def __iadd__(self, other: Vector4) -> Vector4: ...
	def __isub__(self, other: Vector4) -> Vector4: ...
	def __imul__(self, scalar: float) -> Vector4: ...
	def __idiv__(self, scalar: float) -> Vector4: ...
	def __add__(self, other: Vector4) -> Vector4: ...
	def __sub__(self, other: Vector4) -> Vector4: ...
	def __mul__(self, scalar: float) -> Vector4: ...
	def __truediv__(self, scalar: float) -> Vector4: ...

class IntVector4:
	# [x,y,z,w] or [r,g,b,a] are equivalents!
	x : int = 0
	y : int = 0
	z : int = 0
	w : int = 0

	r : int = 0
	g : int = 0
	b : int = 0
	a : int = 0

	def __init__(self): ...
	def __init__(self, value: int): ...
	def __init__(self, x: int, y: int, z: int, w: int): ...
	def __init__(self, other: IntVector4): ...

	def __repr__(self) -> str: ...

	def copy(self) -> IntVector4: ...

class Quaternion:
	x : float = 0
	y : float = 0
	z : float = 0
	w : float = 0

	def __init__(self): ...
	def __init__(self, value: float): ...
	def __init__(self, x: float, y: float, z: float, w: float): ...
	def __init__(self, other: Quaternion): ...

	def __repr__(self) -> str: ...

	def copy(self) -> Quaternion: ...

	def normalize(self) -> None: ...
	def normalized(self) -> Quaternion: ...
	def length(self) -> float: ...

	def lerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def lerpEase(self, other: Quaternion, value: float) -> Quaternion: ...
	def slerp(self, other: Quaternion, value: float) -> Quaternion: ...
	def inversed(self) -> Quaternion: ...
	
	def __neg__(self) -> Quaternion: ...

	# This class also have math operators for the followings:
	# ==, +=, -=, *=, +, -, *

	def __eq__(self, other: Quaternion) -> bool: ...
	def __iadd__(self, other: Quaternion) -> Quaternion: ...
	def __isub__(self, other: Quaternion) -> Quaternion: ...
	def __imul__(self, scalar: float) -> Quaternion: ...
	def __add__(self, other: Quaternion) -> Quaternion: ...
	def __sub__(self, other: Quaternion) -> Quaternion: ...
	def __mul__(self, scalar: float) -> Quaternion: ...

def openWebLink(URL: str) -> None: ... # Opens the given URL in the user's default web browser.
def openApp(executablePath: str) -> bool: ... 
def getCurrentStackTrackBack() -> str: ... 
def isValidFilePath(path: str, fullPath: bool = True) -> bool: ... 
def getInvalidFilePathChar(path: str, fullPath: bool = True) -> int: ... 
def newEmptyEntity() -> Entity: ... 
def newMeshEntity(mesh: str = "Default Cube") -> Entity: ... 
def newLightEntity() -> Entity: ... 
def renderSceneMockFor(entity: Entity, resolution: cave.IntVector2) -> Texture: ... 
def importAssets(localPath: str) -> None: ... 
def importDefaultAssets() -> None: ... 
def reimportDefaultMeshes() -> None: ... 
def showNewAssetMenu() -> Asset: ... 
def showNewEntityPopup(popupName: str) -> Entity: ... 
def newEntityPopup() -> Entity: ... 
def showNewComponentPopup(popupName: str) -> str: ... 
def newScript(componentName: str) -> str: ... 
def addMesh(name: str, addToFiles: bool = True) -> Mesh: ... 
def addTexture(name: str, localPath: str, addToFiles: bool = True) -> ImageTexture: ... 
def addMaterial(name: str, addToFiles: bool = True) -> Material: ... 
def endsWith(fullString: str, ending: str) -> bool: ... 
def endsWith(fullString: str, endings: List[str]) -> bool: ... 
def getFileName(fullPath: str, skipExtension: bool = False) -> str: ... 
def getCurrentTimeInfo() -> str: ... 
def findInString(source: str, filter: str, caseSensitive: bool = False) -> bool: ... 
def startsWith(source: str, prefix: str) -> bool: ... 
def findAndReplace(source: str, oldSubstr: str, newSubstr: str) -> str: ... 
def toTitleCase(variableName: str) -> str: ... 
def splitLines(text: str) -> List[str]: ... 
def formatBytes(bytes: int) -> str: ... 
def formatInteger(number: int) -> str: ... 
def formatInteger(number: int) -> str: ... 
def formatFloat(number: float, fDigits: int = 2) -> str: ... 

class Camera(Transform):
	"""
	The main camera class. Every scene have its own camera instance. Please notice that this is NOT the same as the Camera Component.
	"""


	# Enum: CameraCameraType:# "Camera" class Enumeration.
	PERSPECTIVE : int # Perspective Camera
	ORTHOGRAPHIC : int # Orthographic Camera

	renderMask: BitMask 
	useCustomTransform: bool 
	aperture: float 
	nearPlane: float 
	farPlane: float 
	def __init__(self): ... 
	def getMatrix(self) -> cave.Matrix4: ... 
	def getViewProjection(self) -> cave.Matrix4: ... 
	def getProjection(self) -> cave.Matrix4: ... 
	def getProjection(self, customAspect: float) -> cave.Matrix4: ... 
	def getProjectionType(self) -> Camera.CameraType: ... 
	def getScreenRay(self, x: float, y: float) -> cave.Vector3: ... 
	def getScreenPos(self, worldPos: cave.Vector3) -> cave.Vector2: ... 
	def isVisible(self, worldPos: cave.Vector3) -> bool: ... 
	def setPerspective(self, fieldOfView: float) -> None: ... 
	def setOrthographic(self, orthoArea: float) -> None: ... 
	def getPerspectiveFov(self) -> float: ... 
	def getOrphographicArea(self) -> float: ... 
	def setDistances(self, start: float, end: float) -> None: ... 
	def getAperture(self) -> float: ... 
	def setAperture(self, value: float) -> None: ... 
	def getNearPlane(self) -> float: ... 
	def setNearPlane(self, value: float) -> None: ... 
	def getFarPlane(self) -> float: ... 
	def setFarPlane(self, value: float) -> None: ... 
	def isPerspective(self) -> bool: ... 
	def isOrthographic(self) -> bool: ... 


class Component(Asset):
	"""
	Base class for all Cave Engine Components.
	"""

	entity: Entity 
	def __init__(self): ... 
	def __init__(self, other: Component): ... 
	def getCustomName(self) -> str: ... 
	def start(self, scene: Scene) -> None: ... # This is called once right after the component's owning Entity gets added and/or activated to a given scene.
	def firstUpdate(self) -> None: ... # Called after all the component's owning Entity other components gets their start methods called. You can use this to late initialize stuff that relies on other component's initializations. It's garanteed that it will always be called after the other component's start and before any updates.
	def update(self) -> None: ... # Called every frame if the scene IS NOT paused.
	def pausedUpdate(self) -> None: ... # Called every frame if the scene IS paused.
	def editorUpdate(self) -> None: ... # This method is meant for debug only. It will be called every frame while in the editor mode, even if the game is not being played. Never gets called on standalone (exported game) mode.
	def lateUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... # This is called once right after the component's owning Entity gets removed and/or deactivated from a given scene.
	def reload(self) -> None: ... # Reloads the Component by calling its end() and then its start() methods. It only works if the Component's Entity already belongs to a Scene. Nothing will happen otherwise.
	def getEntity(self) -> Entity: ... 
	def setEntity(self, e: Entity) -> None: ... 


class EditorComponent(Component):
	"""
	This is a Subclass of the Component class that is meant for you to override (Python) and create Editor Tools that are component level. 
When you add an editor component, it will run like any other Components, except that it will also run while in the Editor (without the game enabled). Its editorUpdate method will also be called. 
If you want to write custom Interfaces for it, override the updateInterface method. To initialize persistent variables, either use the Entity's properties OR create an __init__ method.
	"""

	def __init__(self): ... 
	def __init__(self, other: EditorComponent): ... 
	def updateInterface(self) -> None: ... # Called when the Component's Interface tab is being rendered (Editor). You can safely use cave.ui functions here to draw custom Interfaces.


class Entity(Asset):
	"""
	Cave Engine's Entity class.
	"""

	templateEntity: AssetHandler[EntityTemplate] 
	tags: Dict[str,bool] 
	properties: py.dict 
	parent: Entity 
	def __init__(self, name: str = "Entity"): ... 
	def __init__(self, other: Entity): ... 
	def getBoundingBox(self, recursive: bool = True) -> Transform: ... 
	def isActive(self) -> bool: ... 
	def getActive(self) -> bool: ... 
	def setActive(self, value: bool, scene: Scene) -> None: ... 
	def activate(self, scene: Scene) -> None: ... 
	def deactivate(self, scene: Scene) -> None: ... 
	def isTemplated(self, parentRecursive: bool = False) -> bool: ... 
	def getRootTemplate(self) -> Entity: ... 
	def reloadTemplate(self, scene: Scene = None) -> None: ... 
	def setParent(self, parent: Entity) -> bool: ... 
	def removeParent(self) -> None: ... 
	def setParentLocal(self, parent: Entity) -> bool: ... 
	def removeParentLocal(self) -> None: ... 
	def getRootParent(self) -> Entity: ... 
	def getParentLevel(self) -> int: ... 
	def canBeAChildOf(self, ent: Entity) -> bool: ... 
	def getParent(self) -> Entity: ... 
	def getChild(self, name: str, recursive: bool = True) -> Entity: ... 
	def getChildren(self) -> List[Entity]: ... 
	def getChildrenRecursive(self) -> List[Entity]: ... 
	def start(self, scene: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getTransform(self) -> TransformComponent: ... 
	def getScene(self) -> Scene: ... 
	def submitTransformToWorld(self) -> None: ... 
	def add(self, c: Component) -> Component: ... 
	def add(self, cmpName: str) -> Component: ... 
	def get(self, literalName: str) -> Component: ... 
	def get(self, id: int) -> Component: ... 
	def getPy(self, literalName: str) -> Component: ... 
	def getAll(self, literalName: str) -> List[Component]: ... 
	def remove(self, cmp: Component) -> None: ... 
	def remove(self, literalName: str) -> None: ... 
	def removeAll(self, literalName: str) -> None: ... 
	def scheduleKill(self, timeInSeconds: float) -> None: ... 
	def isKillScheduled(self) -> bool: ... 
	def kill(self) -> None: ... 
	def reset(self, deleteChildrens: bool = True) -> None: ... 
	def reload(self, recursive: bool = True) -> None: ... 
	def getComponents(self) -> List[Component]: ... 
	def hasTag(self, tag: str) -> bool: ... 
	def addTag(self, tag: str) -> None: ... 
	def removeTag(self, tag: str) -> None: ... 
	def getTags(self) -> List[str]: ... 
	def hasProperty(self, prop: str) -> bool: ... 
	def isAlive(self) -> bool: ... 
	def setEntityUID(self, value: int) -> None: ... 
	def getIcon(self) -> str: ... 
	def getInternalName(self) -> str: ... 
	def getProperties(self) -> py.dict: ... 


class EntityMap():
	debugAddF: None()() 
	deleteEntitiesOnDestructor: bool 
	def __init__(self): ... 
	def drawDebugUI(self) -> None: ... 
	def update(self) -> None: ... 
	def add(self, object: Entity) -> Entity: ... 
	def remove(self, object: Entity) -> None: ... 
	def cancelRemoval(self, entity: Entity) -> None: ... 
	def get(self, id: int) -> Entity: ... 
	def get(self, name: str) -> Entity: ... 
	def getAll(self) -> List[Entity]: ... 
	def getAllRoots(self) -> List[Entity]: ... 
	def getCount(self) -> int: ... 
	def getAddQueue(self) -> List[Entity]: ... 
	def getRemoveQueue(self) -> List[Entity]: ... 
	def getActive(self) -> Entity: ... 
	def setActive(self, e: Entity, setActiveDebugAsset: bool = True) -> None: ... 


class EntityTemplate(Asset):
	def getBase(self) -> Entity: ... 
	def setBase(self, entity: Entity) -> None: ... 


class Scene(Asset):
	"""
	Main Scene class. This is where all the entities of your Scene are located. You can get the current scene by calling cave.getCurrentScene().
	"""

	uiCanvas: UICanvas 
	properties: py.dict 
	paused: bool # If you set this to True, the scene will go to its paused state, not calling any Entity's update method. It will call their pausedUpdate.
	allowPlay: bool 
	def __init__(self, name: str = "Scene"): ... 
	def isCurrentScene(self) -> bool: ... # Checks if this Scene is the active one.
	def addDefaultObjects(self) -> None: ... 
	def renderToTexture(self, cam: Camera = None, resolution: cave.IntVector2 = glm.ivec2(0,0)) -> Texture: ... 
	def newEntity(self) -> Entity: ... 
	def copyEntity(self, e: Entity) -> Entity: ... 
	def add(self, e: Entity) -> Entity: ... 
	def remove(self, e: Entity) -> None: ... 
	def reloadTemplate(self, templateID: int) -> None: ... 
	def get(self, id: int) -> Entity: ... 
	def get(self, name: str) -> Entity: ... 
	def addFromTemplate(self, templateName: str, position: cave.Vector3 = glm.vec3(0), rotation: cave.Vector3 = glm.vec3(0), scale: cave.Vector3 = glm.vec3(1)) -> Entity: ... 
	def rayCast(self, origin: cave.Vector3, target: cave.Vector3, mask: BitMask = BitMask()) -> RayCastOut: ... 
	def rayCastAll(self, origin: cave.Vector3, target: cave.Vector3, mask: BitMask = BitMask()) -> List[RayCastOut]: ... 
	def sphereCast(self, origin: cave.Vector3, target: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastAll(self, origin: cave.Vector3, target: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> List[SphereCastOut]: ... 
	def checkContactBox(self, box: Transform, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Box (defined by the transform you pass).
	def checkContactBox(self, pos: cave.Vector3, rot: cave.Quaternion, scale: cave.Vector3, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Box (defined by the position, rotation and scale you pass).
	def checkContactSphere(self, pos: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... # You can use this method to do Collision queries using a Sphere (defined by the position and radius you pass).
	def addDebugLine(self, origin: cave.Vector3, target: cave.Vector3, color: cave.Vector3) -> None: ... 
	def addDebugArrow(self, origin: cave.Vector3, target: cave.Vector3, color: cave.Vector3) -> None: ... 
	def addDebugPoint(self, position: cave.Vector3, color: cave.Vector3) -> None: ... # Draws a Debug Point in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCube(self, transform: Transform, color: cave.Vector3) -> None: ... # Draws a Debug Cube in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCircle(self, transform: Transform, color: cave.Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Circle in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugCircle(self, position: cave.Vector3, radius: float, color: cave.Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Circle in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def addDebugSphere(self, position: cave.Vector3, radius: float, color: cave.Vector3, numVertices: int = 8) -> None: ... # Draws a Debug Sphere in the 3D Space. This is only visible while in the Editor, meaning that it won't appear in the Game's runtime (exported project).
	def getCamera(self) -> Camera: ... # Gets the Scene's camera instance. This is the actual camera used by the Engine to render the Scene.
	def getSunLight(self) -> RenderableSun: ... 
	def getSunLightPtr(self) -> RenderableSun: ... 
	def getBoundingBox(self) -> Transform: ... 
	def getBoundingBoxPhysics(self) -> Transform: ... 
	def getRenderGraphConfig(self) -> RenderGraph.Config: ... 
	def getPostProcessingOverride(self) -> str: ... 
	def setPostProcessingOverride(self, postProcessing: str) -> None: ... 
	def resetElapsedSceneTime(self) -> None: ... 
	def incrementElapsedSceneTime(self) -> None: ... 
	def getElapsedSceneTime(self) -> float: ... 
	def playTimeline(self, name: str, loop: bool = False, playWhenPaused: bool = False, restoreCameraOnEnd: bool = True) -> None: ... 
	def isTimelineBeingPlayed(self, name: str) -> bool: ... 
	def isAnyTimelineBeingPlayed(self) -> bool: ... 
	def getNumTimelinesBeingPlayed(self) -> int: ... 
	def stopTimeline(self, name: str) -> None: ... 
	def stopAllTimelines(self) -> None: ... 
	def getTimelineProgress(self, name: str) -> float: ... 
	def getTimelineFrame(self, name: str) -> float: ... 
	def getTimelineLoops(self, name: str) -> int: ... 
	def getEntities(self) -> List[Entity]: ... 
	def getEntitiesWithTag(self, tag: str) -> List[Entity]: ... 
	def getEntitiesWithName(self, name: str) -> List[Entity]: ... 
	def getEntitiesWithProperty(self, prop: str) -> List[Entity]: ... 
	def getRootEntities(self) -> List[Entity]: ... 
	def getRootEntitiesWithTag(self, tag: str) -> List[Entity]: ... 
	def getRootEntitiesWithProperty(self, prop: str) -> List[Entity]: ... 
	def getEntitiesFromTemplate(self, templateName: str) -> List[Entity]: ... 
	def getEntitiesWithComponent(self, componentName: str, searchPythonComponents: bool = False) -> List[Entity]: ... 
	def getEntitiesHandler(self) -> EntityMap: ... 
	def getActiveEntity(self) -> Entity: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def getProperties(self) -> py.dict: ... 


class Asset():
	name: str 
	debug: Debug 
	uID: int 
	def getUID(self) -> int: ... 
	def getUniqueName(self) -> str: ... 
	def getAssetFileName(self) -> str: ... 
	def getAssetTypeName(self) -> str: ... 
	def getThumbnail(self, generateIfNone: bool = True, forceRegenation: bool = False) -> Texture: ... 


class AssetDebug():
	thumbnail: Texture 
	thumbnailFlip: bool 
	dirty: bool 
	serializeAsJson: bool 
	handler: AssetFile 


class AssetData():
	mainScene: AssetHandler[Scene] 
	def __init__(self): ... 
	def importRawAsset(self, absPath: str, skipAdvanced: bool = False) -> bool: ... 
	def importRawAssetsRecursive(self, path: str, absolute: bool = False) -> None: ... 
	def clear(self, freeMemory: bool = False) -> None: ... 
	def merge(self, data: AssetData, replaceDuplis: bool = False) -> None: ... 
	def getAssetMap(self, classId: int, createIfNone: bool = True) -> AssetMap: ... 
	def getAssetMaps(self) -> List[AssetMap]: ... 
	def getAssetMaps(self, mode: FactoryMode) -> List[AssetMap]: ... 
	def get(self, assetId: int) -> Asset: ... 
	def getAssetCount(self) -> int: ... 
	def resetFileSystem(self) -> None: ... 
	def drawUINewAssetMenu(self) -> Asset: ... 
	def scanAssets(self) -> None: ... 
	def setSelectedFile(self, file: AssetFile, markForRecovery: bool = True) -> None: ... 
	def getSelectedFile(self, rootIfNone: bool = True, attemptToRecover: bool = True) -> AssetFile: ... 
	def getRootFile(self) -> AssetFile: ... 
	def getFileAt(self, path: str, createIfNone: bool = True) -> AssetFile: ... 


class CavePackageDescriptor():
	name: str 
	description: str 
	author: str 
	date: str 
	thumbnail: AssetHandler[Texture] 
	thumbTexture: ImageTexture 
	def __init__(self): ... 


class AssetFile(Asset):
	selected: bool 
	def __init__(self, name: str = "Folder"): ... 
	def __init__(self, asset: Asset): ... 
	def __init__(self, other: AssetFile): ... 
	def export(self, file: File, desc: CavePackageDescriptor = None, all: bool = True) -> None: ... 
	def import(self, file: File, desc: CavePackageDescriptor = None, all: bool = True) -> None: ... 
	def getPath(self) -> str: ... 
	def sortChildren(self) -> None: ... 
	def agroupChildren(self) -> None: ... 
	def dissolveFolder(self) -> bool: ... 
	def drawThumbnail(self, width: float = 128, height: float = 128, generateThumb: bool = True) -> bool: ... 
	def drawFolderElements(self, zoom: float = 1) -> None: ... 
	def drawFolderHierarchy(self, name: str = "", icon: str = "") -> None: ... 
	def drawFolderHeader(self) -> None: ... 
	def isFolder(self) -> bool: ... 
	def isAsset(self) -> bool: ... 
	def isDirty(self) -> bool: ... 
	def markAsDirty(self) -> None: ... 
	def markAsNotDirty(self) -> None: ... 
	def getParent(self) -> AssetFile: ... 
	def addChild(self, child: AssetFile) -> bool: ... 
	def addChildAsset(self, asset: Asset) -> bool: ... 
	def removeChild(self, child: AssetFile) -> bool: ... 
	def removeEmptyFolders(self) -> None: ... 
	def canBeAChildOf(self, parent: AssetFile) -> bool: ... 
	def getChild(self, name: str) -> AssetFile: ... 
	def getChildRecursive(self, childID: int) -> AssetFile: ... 
	def getChildFolder(self, name: str) -> AssetFile: ... 
	def getChildren(self) -> List[AssetFile]: ... 
	def getChildrenRecursive(self) -> List[AssetFile]: ... 
	def getName(self) -> str: ... 
	def getUniqueAssetFileName(self) -> str: ... 
	def getUniqueAssetFileID(self) -> int: ... 
	def setName(self, value: str) -> None: ... 
	def getAsset(self) -> Asset: ... 
	def isOrphan(self) -> bool: ... 


class IAssetHandler():

	# Enum: IAssetHandlerMode:# "IAssetHandler" class Enumeration.
	FROM_ASSET_DATA : int 
	FROM_WEAK_REF : int 
	FROM_LOCAL : int 

	name: str 
	def setAsset(self, asset: Asset) -> None: ... 
	def setAsset(self, name: str, searchChildren: bool = True) -> None: ... 
	def getAssetUID(self) -> int: ... 
	def getAsset(self, markAsDirty: bool = True, searchChildren: bool = False) -> Asset: ... 
	def isLocal(self) -> bool: ... 
	def isWeakRef(self) -> bool: ... 
	def isFromAssetData(self) -> bool: ... 
	def saveToAssetData(self, filePath: str = "") -> bool: ... 


class AssetImporter():
	data: AssetData 
	createSubfolder: bool 
	transformOverride: Transform 
	def __init__(self, fileName: str): ... 
	def sendToApp(self, applyTransformOverride: bool = True) -> None: ... 
	def getFileName(self) -> str: ... 
	def getFilter(self, asset: Asset) -> bool: ... 
	def isFiltered(self, asset: Asset) -> bool: ... 


class AssetMap():
	def __init__(self, classID: int, ownerData: AssetData): ... 
	def clear(self, freeMemory: bool = False) -> None: ... 
	def get(self, name: str, searchChildren: bool = False) -> Asset: ... 
	def get(self, id: int, searchChildren: bool = False) -> Asset: ... 
	def getAll(self, includeChildren: bool = True) -> List[Asset]: ... 
	def getAll(self, name: str, includeChildren: bool = True) -> List[Asset]: ... 
	def addNewFromUI(self) -> Asset: ... 
	def addCopyFromUI(self, source: Asset) -> Asset: ... 
	def add(self, data: Asset, replaceDuplis: bool = False) -> bool: ... 
	def merge(self, other: AssetMap, replaceDuplis: bool = False) -> None: ... 
	def remove(self, name: str, freeMemory: bool = True) -> bool: ... 
	def remove(self, id: int, freeMemory: bool = True) -> bool: ... 
	def getMapClassID(self) -> int: ... 
	def getAssetCount(self) -> int: ... 
	def getNames(self, includeId: bool = False) -> List[str]: ... 
	def getIDs(self) -> List[int]: ... 



# Enum: FactoryMode: 
COMPONENT : int 
REGULAR : int 
UNLISTED : int 
LISTED : int 
LISTED_NOADD : int 



class UniqueID():
	def __init__(self): ... 
	def __init__(self, other: UniqueID): ... 
	def get(self) -> int: ... 
	def set(self, value: int) -> None: ... 
	def __eq__(self, other) -> bool: ... # self == other
	def __ne__(self, other) -> bool: ... # self != other
	def __str__(self) -> str: ...


class LevelDescriptor(Asset):
	objects: List[LevelObject] 
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def buildLevel(self, s: Scene, addCollisions: bool = False) -> None: ... 


class LevelObject():
	name: str 
	transform: Transform 
	slots: List[Slot] 
	children: List[LevelObject] 
	def __init__(self): ... 
	def buildEntity(self, addCollisions: bool = False) -> Entity: ... 


class LevelObjectSlot():
	mesh: AssetHandler[Mesh] 
	material: AssetHandler[Material] 
	animation: AssetHandler[Animation] 
	armature: AssetHandler[Armature] 


class AudioDevice():
	debug: _Debug 
	def __init__(self, _sampleRate: int = 44100): ... 
	def playTrack(self, audio: AudioTrack, loops: int = 0, volume: float = 1, pitch: float = 1, startPaused: bool = False) -> int: ... 
	def stopTrack(self, audio: AudioTrack) -> int: ... 
	def update(self, scene: Scene) -> None: ... 
	def getSampleRate(self) -> int: ... 
	def drawUIMonitor(self) -> None: ... 
	def drawUIQueue(self) -> None: ... 
	def pauseAll(self) -> None: ... 
	def resumeAll(self) -> None: ... 
	def stopAll(self) -> None: ... 
	def isValid(self, handlerID: int) -> bool: ... 
	def isPlaying(self, handlerID: int) -> bool: ... 
	def isPaused(self, handlerID: int) -> bool: ... 
	def setPaused(self, handlerID: int, paused: bool) -> None: ... 
	def getPaused(self, handlerID: int) -> bool: ... 
	def pause(self, handlerID: int) -> None: ... 
	def unpause(self, handlerID: int) -> None: ... 
	def stop(self, handlerID: int) -> None: ... 
	def setLoops(self, handlerID: int, loops: int) -> None: ... 
	def getLoops(self, handlerID: int) -> int: ... 
	def setVolume(self, handlerID: int, volume: float) -> None: ... 
	def getVolume(self, handlerID: int) -> float: ... 
	def setPitch(self, handlerID: int, pitch: float) -> None: ... 
	def getPitch(self, handlerID: int) -> float: ... 
	def setProgress(self, handlerID: int, progress: float) -> None: ... 
	def getProgress(self, handlerID: int) -> float: ... 
	def setSource3D(self, handlerID: int, x: float, y: float, z: float, distance: float) -> None: ... 
	def setSource3D(self, handlerID: int, entityID: int, distance: float) -> None: ... 
	def setPan(self, handlerID: int, pan: float) -> None: ... 
	def getAudio(self, handlerID: int, markAsDirty: bool = True) -> AudioTrack: ... 


class AudioTrack(Asset):
	def __init__(self): ... 
	def __init__(self, filename: str): ... 
	def uIDoubleClicked(self) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def exportOgg(self, filename: str) -> None: ... 
	def replaceOgg(self, filename: str) -> None: ... 
	def play(self, volume: float = 1, loop: int = 0, pitch: float = 1, startPaused: bool = False) -> AudioTrackInstance: ... 
	def stopAll(self) -> None: ... 
	def getDuration(self) -> float: ... 
	def getNumSamples(self) -> int: ... 
	def getNumChannels(self) -> int: ... 
	def getSampleRate(self) -> int: ... 
	def getSizeOnDisk(self) -> int: ... 
	def getSizeDecoded(self) -> int: ... 
	def getSamples(self) -> List[int]: ... 


class AudioTrackInstance():
	progress: float 
	volume: float 
	pitch: float 
	def __init__(self, handler: int = 0): ... 
	def __init__(self, other: AudioTrackInstance): ... 
	def play(self, loop: int) -> None: ... 
	def pause(self) -> None: ... 
	def resume(self) -> None: ... 
	def stop(self, fadeOut: float = 0) -> None: ... 
	def getProgress(self) -> float: ... 
	def setProgress(self, value: float) -> None: ... 
	def getDuration(self) -> float: ... 
	def setLoop(self, loop: int) -> None: ... 
	def setSource3D(self, source: Entity, maxDistance: float = 100) -> None: ... 
	def calculate3D(self, audioPos: cave.Vector3, maxDistance: float = 100) -> bool: ... 
	def isActive(self) -> bool: ... 
	def isPlaying(self) -> bool: ... 
	def isPaused(self) -> bool: ... 
	def isValid(self) -> bool: ... 
	def setVolume(self, value: float) -> None: ... 
	def getVolume(self) -> float: ... 
	def getPitch(self) -> float: ... 
	def setPitch(self, pitch: float) -> None: ... 
	def setPan(self, pan: float) -> None: ... 
	def getTrack(self) -> AudioTrack: ... 


class Events():
	def update(self) -> None: ... 
	def forceQuit(self) -> None: ... 
	def refuseQuitStatus(self) -> None: ... 
	def getQuitStatus(self) -> bool: ... 
	def hasResized(self) -> bool: ... 
	def getJoystickCount(self) -> int: ... 
	def getJoystickName(self, id: int) -> str: ... 
	def getJoystick(self, id: int) -> Events.Joystick: ... 
	def getMouseScroll(self) -> float: ... 
	def pressed(self, t: event.Type) -> bool: ... 
	def active(self, t: event.Type) -> bool: ... 
	def released(self, t: event.Type) -> bool: ... 
	def pressed(self, t: str) -> bool: ... 
	def active(self, t: str) -> bool: ... 
	def released(self, t: str) -> bool: ... 
	def getMouseMotion(self) -> cave.Vector2: ... 
	def setRelativeMouse(self, value: bool) -> None: ... 
	def popDroppedFiles(self) -> List[str]: ... 
	def getKeyStatus(self, t: event.Type) -> event.Status: ... 
	def getSDLEventPool(self) -> List[SDL_Event]: ... 


class EventsJoystick():
	def isValid(self) -> bool: ... 
	def getName(self) -> str: ... 
	def getType(self) -> str: ... 
	def getIndex(self) -> int: ... 
	def getInstanceID(self) -> int: ... 
	def hasVibration(self) -> bool: ... 
	def hasLED(self) -> bool: ... 
	def hasAccelerometer(self) -> bool: ... 
	def hasGyroscope(self) -> bool: ... 
	def setAccelerometerEnabled(self, value: bool) -> None: ... 
	def setGyroscopeEnabled(self, value: bool) -> None: ... 
	def getAccelerometer(self) -> cave.Vector3: ... 
	def getGyroscope(self) -> cave.Vector3: ... 
	def isGameController(self) -> bool: ... 
	def hasAxis(self, axis: event.Controller) -> bool: ... 
	def hasButton(self, axis: event.Controller) -> bool: ... 
	def getAxisLeft(self, tolerance: float = 0.1) -> cave.Vector2: ... 
	def getAxisRight(self, tolerance: float = 0.1) -> cave.Vector2: ... 
	def getTriggerLeft(self) -> float: ... 
	def getTriggerRight(self) -> float: ... 
	def getControllerButton(self, btn: event.Controller) -> bool: ... 
	def getNumTouchpads(self) -> int: ... 
	def getNumTouchpadFingers(self, touchpad: int) -> int: ... 
	def getTouchpadFinger(self, touchpad: int, finger: int) -> cave.Vector3: ... 
	def pressed(self, btn: event.Controller) -> bool: ... 
	def active(self, btn: event.Controller) -> bool: ... 
	def released(self, btn: event.Controller) -> bool: ... 
	def buttonPressed(self, btn: int) -> bool: ... 
	def buttonActive(self, btn: int) -> bool: ... 
	def buttonReleased(self, btn: int) -> bool: ... 
	def setLED(self, r: float, g: float, b: float) -> None: ... 
	def vibrate(self, left: float = 1, right: float = 1, duration: float = 0.5) -> None: ... 
	def getPowerLevel(self) -> str: ... 
	def getNumAxes(self) -> int: ... 
	def getNumBalls(self) -> int: ... 
	def getNumButtons(self) -> int: ... 
	def getNumHats(self) -> int: ... 
	def getAxis(self, axis: int, tolerance: float = 0.1) -> float: ... 
	def getAxisInitialState(self, axis: int) -> float: ... 
	def getBall(self, ball: int) -> cave.IntVector2: ... 
	def getButton(self, button: int) -> bool: ... 
	def getHat(self, hat: int) -> cave.IntVector2: ... 


class DebugTab():
	active: bool 
	def __init__(self): ... 
	def draw(self, fontScale: float = 1.0) -> bool: ... 
	def getName(self) -> str: ... 


class DebugTool():

	# Enum: DebugToolRunStatus:# "DebugTool" class Enumeration.
	FINISHED : int 
	RUNNING : int 

	name: str 
	message: str 
	def isEnabled(self) -> bool: ... 
	def run(self, currentEntity: Entity) -> DebugTool.RunStatus: ... 
	def drawMenu(self) -> None: ... 


class DebugUI():
	active: bool 
	showTopMenu: bool 
	locale: Localization 
	clipboard: DebugClipboard 
	activeAsset: Asset 
	activeTimeline: Timeline 
	activeSourceCode: SourceCode 
	resetAssetHistoric: bool 
	fontScale: float 
	def __init__(self, window: Window): ... 
	def update(self, events: Events) -> None: ... 
	def draw(self, window: Window) -> None: ... 
	def canQuit(self) -> bool: ... 
	def saveProject(self, dirtyOnly: bool = False) -> None: ... 
	def loadEditor(self) -> None: ... 
	def importRawAsset(self, filePath: str) -> None: ... 
	def loadEditorTools(self) -> None: ... 
	def addTab(self, tab: DebugTab) -> None: ... 
	def addOrReplaceTab(self, tab: DebugTab) -> None: ... 
	def setFocus(self, tab: DebugTab) -> None: ... 
	def resetFontScale(self) -> None: ... 
	def setFontScale(self, value: float) -> None: ... 
	def getFontScale(self) -> float: ... 
	def getFontScaleGain(self) -> float: ... 
	def runDPICheck(self) -> None: ... 
	def notify(self, message: str) -> None: ... 


class DebugUIDebugClipboard():
	entity: Entity 
	component: Component 


class Localization():
	def __init__(self): ... 
	def get(self, text: str) -> str: ... 


class LocalizationTab(DebugTab):
	def __init__(self): ... 
	def getName(self) -> str: ... 


class SceneTemplateEditor(Scene):
	reloadOnDestructor: bool 
	def __init__(self, base: EntityTemplate): ... 
	def end(self) -> None: ... 
	def endUpdate(self) -> None: ... 
	def getBase(self) -> EntityTemplate: ... 


class ConsoleTab(DebugTab):
	clearOnPlay: bool 
	def __init__(self): ... 
	def getName(self) -> str: ... 
	def showMessage(self, message: ConsoleMessage) -> None: ... 
	def drawUIFooter(self) -> None: ... 
	def clear(self) -> None: ... 


class ProfilerTab(DebugTab):
	def __init__(self): ... 
	def getName(self) -> str: ... 


class StatsForNerdsTab(DebugTab):
	counters: Counters 
	time: Timers 
	def __init__(self): ... 
	def onGameStart(self) -> None: ... 
	def onGameStop(self) -> None: ... 
	def onFirstLoad(self) -> None: ... 
	def getName(self) -> str: ... 
	def updateTimers(self) -> None: ... 


class StatsForNerdsTabCounters():
	loadedTheProject: int 
	savedTheProject: int 
	startedTheGame: int 


class StatsForNerdsTabTimers():
	inEditor: float 
	inGame: float 


class ViewportTab(DebugTab):
	config: ViewportConfig 
	displayMessage: str 
	def __init__(self): ... 
	def addTool(self, tool: DebugTool) -> None: ... 
	def getName(self) -> str: ... 
	def getMouseSurfacePos(self) -> cave.Vector2: ... 
	def isUIElementsHovered(self) -> UIElementComponent: ... 
	def getViewportSize(self) -> cave.Vector2: ... 
	def startGame(self) -> None: ... 
	def stopGame(self) -> None: ... 
	def scheduleStopGame(self) -> None: ... 
	def isUsingSnapping(self) -> bool: ... 


class ViewportTabViewportConfig():
	drawGizmos: bool 
	drawDebugIcons: bool 
	debugShadowMap: bool 
	debugRenderOut: bool 
	mouselookSens: float 


class Blur():
	size: float 
	def __init__(self, width: int, height: int, imageResReduction: float = 1.0): ... 
	def resize(self, width: int, height: int) -> None: ... 
	def blurImage(self, texture: Texture, blurAmount: int = 10) -> None: ... 
	def useBlurredImage(self, position: int) -> None: ... 
	def getBlurredImage(self) -> Texture: ... 
	def getSize(self) -> float: ... 
	def setSize(self, size: float = 1) -> None: ... 



def showMouse(show: bool) -> None: ... 
def clearBuffers(r: float, g: float, b: float, a: float = 1) -> None: ... 
def setViewport(width: int, height: int) -> None: ... 
def setViewport(x: int, y: int, w: int, h: int) -> None: ... 
def init() -> None: ... 
def setTarget(window: Window) -> None: ... 
def setTarget(texture: Texture, depthTexture: Texture = None) -> None: ... 
def setTarget(textures: List[Texture], depthTexture: Texture = None) -> None: ... 
def addShader(path: str, source: str) -> None: ... 
def getShader(path: str) -> str: ... 
def removeShader(path: str) -> None: ... 
def resolveShaderIncludes(rawShader: str) -> str: ... 
def addGeneratedShaders() -> None: ... 
def drawWireframe(value: bool) -> None: ... 
def depthTest(value: bool) -> None: ... 
def faceCulling(value: bool, backFace: bool = True) -> None: ... 
def enableErrorChecking() -> None: ... 
def disableErrorChecking() -> None: ... 
def isErrorCheckingEnabled() -> bool: ... 
def checkError(errorTitle: str, errorBody: str, showErrorDialog: bool = True, displayErrorInLog: bool = True, supressInvalidOperation: bool = True) -> bool: ... 
def createShader(name: str, source: str, type: GLenum) -> GLuint: ... 
def checkShaderError(shader: GLuint, flag: GLuint, isProgram: bool) -> str: ... 
def enableOpenGL4Features() -> None: ... 
def pushDebugGroup(msg: str) -> None: ... 
def popDebugGroup() -> None: ... 
def nameObject(identifier: GLenum, name: GLuint, label: str) -> None: ... 

class Vertex():
	position: cave.Vector3 
	normal: cave.Vector3 
	tangent: cave.Vector3 
	uv: cave.Vector2 
	def __init__(self): ... 


class VertexJoints():
	weights: cave.Vector4 
	jointIDs: cave.Vector4 
	def __init__(self): ... 


class VertexInfo():
	data: Vertex 
	joints: VertexJoints 


class Mesh(Asset):

	# Enum: MeshDefaultMeshes:# "Mesh" class Enumeration.
	PLANE : int 
	CUBE : int 
	CYLINDER : int 
	CONE : int 
	UV_SPHERE : int 
	GRID : int 


	# Enum: MeshShadowPassRule:# "Mesh" class Enumeration.
	USE_CURRENT_LOD_LEVEL : int 
	ALWAYS_USE_LAST_LOD_LEVEL : int 
	SKIP_SHADOW_PASS : int 

	vertices: List[Vertex] 
	joints: List[VertexJoints] 
	indices: List[int] 
	lod0range: float 
	lod: List[LodData] 
	distanceCulling: MeshDistanceCulling 
	shadowPassRule: ShadowPassRule 
	hints: MeshHints 
	def __init__(self): ... 
	def __init__(self, other: Mesh): ... 
	def getPhysicsMesh(self, createIfNone: bool = True) -> PhysicsMesh: ... 
	def rebuildPhysicsMesh(self) -> None: ... 
	def bindMeshBuffersData(self) -> None: ... 
	def reset(self, resetData: bool = True) -> None: ... 
	def reload(self) -> None: ... 
	def recalculateTangents(self, useUVs: bool = False) -> None: ... 
	def recalculateNormals(self) -> None: ... 
	def flipNormals(self) -> None: ... 
	def applyShadeFlat(self) -> None: ... 
	def flipIndices(self) -> None: ... 
	def recalculateIndices(self) -> None: ... 
	def mergeByDistance(self, distance: float = 0.001, ignoreUVs: bool = False, ignoreNormals: bool = False, reload: bool = True) -> None: ... 
	def mergeByDistanceFast(self, decimals: int = 4, reload: bool = True) -> None: ... 
	def mergeJointsByDistance(self, distance: float = 0.001, reload: bool = True) -> None: ... 
	def removeLooseVertices(self, reload: bool = True) -> None: ... 
	def optimizeMesh(self, reload: bool = True) -> None: ... 
	def uIDoubleClicked(self) -> None: ... 
	def use(self) -> int: ... 
	def useLod(self, lodLevel: int = 0) -> int: ... 
	def getLodLevelForDistance(self, distance: float) -> int: ... 
	def draw(self) -> None: ... 
	def drawInstanced(self, instanceCount: int) -> None: ... 
	def drawLines(self, width: float = 1) -> None: ... 
	def drawPoints(self, thickness: float = 5) -> None: ... 
	def getCopy(self) -> Mesh: ... 
	def getRandomPoint(self) -> Vertex: ... 
	def getBoundingBox(self, keepAspect: bool = True, transf: Transform = None) -> Transform: ... 
	def getCachedBoundingBox(self) -> cave.Matrix4: ... 
	def recalculateCachedBoundingBox(self) -> None: ... 
	def removeAnimationJointsIfUnused(self, reload: bool = True) -> None: ... 
	def hasAnimationData(self) -> bool: ... 
	def appendVertex(self, pos: cave.Vector3, normal: cave.Vector3, tangent: cave.Vector3, uv: cave.Vector2) -> None: ... 
	def addLine(self, origin: cave.Vector3, target: cave.Vector3, color: cave.Vector3) -> None: ... 
	def mergeVertices(self, targetIdx: int, otherIdx: int) -> bool: ... 
	def getEdges(self, vertexIdx: int) -> Tuple[int]: ... 
	def getFaces(self, vertexIdx: int) -> Tuple[int]: ... 
	def getAllEdges(self) -> Tuple[Tuple[int,int]]: ... 
	def getAverageNormalLength(self, vertexIdx: int) -> float: ... 
	def decimate(self, ratio: float = 0.5, reload: bool = True) -> None: ... 
	def generateLodLevels(self, lodLevels: int = 1, distanceFactor: float = 3, reload: bool = True) -> None: ... 
	def addFace(self, vList: List[Vertex]) -> None: ... 
	def addMesh(self, other: Mesh) -> None: ... 
	def addMeshTransformed(self, other: Mesh, transform: Transform) -> None: ... 
	def addVolume(self, transform: Transform) -> None: ... 
	def addNgon(self, ngon: List[cave.Vector3]) -> None: ... 
	def addNgon(self, ngon: List[Vertex]) -> None: ... 
	def applyTransform(self, transform: Transform, bindData: bool = True) -> None: ... 
	def applyMovement(self, move: cave.Vector3, bindData: bool = True) -> None: ... 
	def getCurrentIndicesCount(self) -> int: ... 
	def getObj(self, indicesOffset: int = 0) -> str: ... 
	def buildMeshWithLod(self, lodLevel: int, bindData: bool = True) -> Mesh: ... 
	def disableShadowRendering(self) -> None: ... 
	def enableShadowRendering(self, useLastLod: bool = False) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 


class MeshLodData():
	indices: List[int] 
	range: float 
	ratio: float 


class MeshMeshDistanceCulling():
	enable: bool 
	enableDither: bool 
	distance: float 


class MeshMeshHints():
	transform: Transform 
	material: AssetHandler[Material] 
	armature: AssetHandler[Armature] 
	animation: AssetHandler[Animation] 


class PostProcessing(Asset):
	passes: List[Filter] 
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 


class PostProcessingFilter():
	name: str 
	active: bool 
	uniforms: ShaderUniforms 
	bindPyCodeStaging: SourceCode 
	bindPyCode: str 
	shader: ShaderProgram 
	def __init__(self): ... 
	def __init__(self, shaderSource: str): ... 
	def isValid(self) -> bool: ... 
	def submit(self) -> None: ... 
	def parseUniforms(self) -> None: ... 


class Renderer(Asset):
	postProcessing: AssetHandler[PostProcessing] 
	shaderProgramOverride: AssetHandler[ShaderProgram] 
	def __init__(self): ... 
	def render(self, view: Camera, rGraph: RenderGraph, renderToTexture: bool = False) -> None: ... 
	def renderToTexture(self, view: Camera, rGraph: RenderGraph, resolution: cave.IntVector2 = glm.ivec2(0,0)) -> Texture: ... 
	def setResolution(self, width: int, height: int, force: bool = False) -> None: ... 
	def setResolution(self, res: cave.IntVector2, force: bool = False) -> None: ... 
	def getResolution(self) -> cave.IntVector2: ... 
	def setVirtualAspect(self, aspect: float) -> None: ... 
	def getAspect(self) -> float: ... 
	def getFinalRender(self) -> Texture: ... 
	def getFinalRenderBlurred(self) -> Texture: ... 
	def getPositionAt(self, x: float, y: float) -> cave.Vector4: ... 
	def getNormalAt(self, x: float, y: float) -> cave.Vector4: ... 
	def getAssetAt(self, x: float, y: float) -> Asset: ... 
	def getMainShader(self, markAsDirty: bool = True) -> ShaderProgram: ... 
	def getDefaultTextures(self) -> List[Texture]: ... 
	def getShadowTexture(self) -> Texture: ... 



# Enum: ShaderProgramMacros: 
SHADER_SHADOW_PASS : int 
SHADER_DECAL_PASS : int 
SHADER_ALPHA_BLEND : int 
SHADER_MATERIAL_SHADELESS : int 
SHADER_MATERIAL_HAS_NORMAL_MAP : int 
SHADER_SCENE_SHADED : int 
SHADER_SCENE_HAS_AMBIENT : int 
SHADER_SCENE_HAS_MIST : int 
SHADER_SCENE_HAS_SHADOWS : int 

class ShaderProgram(Asset):
	uniforms: ShaderUniforms 
	vertex: SourceCode 
	geometry: SourceCode 
	fragment: SourceCode 
	def __init__(self): ... 
	def __init__(self, vert: str, frag: str): ... 
	def __init__(self, vert: str, geom: str, frag: str): ... 
	def __init__(self, other: ShaderProgram): ... 
	def isValid(self) -> bool: ... 
	def reload(self) -> None: ... 
	def use(self, permutation: int = 0) -> None: ... 
	def set(self, name: str, value: int) -> None: ... 
	def set(self, name: str, value: int) -> None: ... 
	def set(self, name: str, value: bool) -> None: ... 
	def set(self, name: str, value: float) -> None: ... 
	def set(self, name: str, value: cave.Vector2) -> None: ... 
	def set(self, name: str, value: cave.IntVector2) -> None: ... 
	def set(self, name: str, value: cave.Vector3) -> None: ... 
	def set(self, name: str, value: cave.IntVector3) -> None: ... 
	def set(self, name: str, value: cave.Vector4) -> None: ... 
	def set(self, name: str, value: cave.IntVector4) -> None: ... 
	def set(self, name: str, value: cave.Matrix3) -> None: ... 
	def set(self, name: str, value: cave.Matrix4) -> None: ... 
	def setUniformBuffer(self, name: str, bindingPoint: int) -> None: ... 


class ShaderUniforms():
	def __init__(self): ... 
	def __init__(self, other: ShaderUniforms): ... 
	def reset(self) -> None: ... 
	def parse(self, shaderSource: str) -> None: ... 
	def sync(self, base: ShaderUniforms) -> None: ... 
	def bind(self, shader: ShaderProgram, nextTexLocation: int) -> None: ... 


class TextureParameters():
	wrapX: int 
	wrapY: int 
	minFilter: int 
	magFilter: int 
	borderColor: cave.Vector4 


class Texture(Asset):
	def saveAsPNG(self, filePath: str) -> None: ... 
	def readPixels(self) -> List[int]: ... 
	def readPixelFloat(self, x: float, y: float) -> cave.Vector4: ... 
	def readPixelFloatAbsolute(self, x: int, y: int) -> cave.Vector4: ... 
	def getTextureID(self) -> int: ... 
	def getHeight(self) -> int: ... 
	def getWidth(self) -> int: ... 
	def getResolution(self) -> cave.IntVector2: ... 
	def getAspect(self) -> float: ... 


class UniformBuffer():
	def __init__(self, size: int, bindingPoint: GLuint, usageHint: GLenum = GL_DYNAMIC_DRAW): ... 
	def use(self) -> None: ... 
	def setBufferData(self, offset: int, ptrData: None, dataSize: int) -> None: ... 
	def useAndSetBufferData(self, offset: int, ptrData: None, dataSize: int) -> None: ... 
	def getBufferID(self) -> GLuint: ... 
	def getBindingPoint(self) -> GLuint: ... 


class SceneUBO():
	applyAmbient: int 
	ambientFactor: float 
	applyShading: int 
	mistUse: int 
	mistStart: float 
	mistDistance: float 
	mistFalloff: float 
	cameraPosition: cave.Vector3 
	cameraAperture: float 
	cameraNear: float 
	cameraFar: float 
	cameraInvVP: cave.Matrix4 
	useShadows: int 
	shadowPCFsamples: int 
	shadowPCFradius: float 
	shadowBias: float 
	shadowBiasAngleScale: float 
	shadowInfluence: float 
	sunDir: cave.Vector3 
	sunColor: cave.Vector3 
	sunViewProjection: cave.Matrix4 
	sunPlanes: cave.Vector2 
	sunPos: cave.Vector3 


class PointLightInfoUBO():
	position: cave.Vector3 
	color: cave.Vector3 
	radius: float 


class PointLightsUBO():
	pointLightCount: int 


class InstanceInfoUBO():
	transform: cave.Matrix4 
	tint: cave.Vector4 
	id: cave.IntVector4 


class InstancesUBO():


class MaterialUBO():
	shadeless: int 
	alphaBlend: int 
	alphaValue: float 
	displacementScale: float 
	normalInfluence: float 
	hasNormal: int 
	mask: float 


class ArmatureUBO():
	boneCount: int 


class Animation(Asset):
	frameStart: float 
	frameEnd: float 
	speed: float 
	rootMotion: RootMotion 
	callbacks: Callbacks 
	def __init__(self): ... 
	def __init__(self, start: float, end: float): ... 
	def __init__(self, other: Animation): ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def uIDoubleClicked(self) -> None: ... 
	def uIThumbnailDrawn(self, pos: cave.Vector2, size: cave.Vector2) -> None: ... 
	def getTransformAt(self, channelName: str, frame: float) -> Transform: ... 
	def getChannel(self, channelName: str, addIfNone: bool = True) -> AnimationChannels: ... 
	def getChannels(self) -> Dict[str,AnimationChannels]: ... 


class AnimationRootMotion():
	channel: str 
	x: bool 
	y: bool 
	z: bool 


class AnimationCallbacks():
	onStart: SourceCode 
	onEnd: SourceCode 
	onFrame: List[Tuple[float,SourceCode]] 



# Enum: AnimationInterpolation: 
LINEAR : int 
CONSTANT : int 

class AnimationChannels():
	interpolation: AnimationInterpolation 
	def __init__(self): ... 
	def __init__(self, other: AnimationChannels): ... 
	def drawUISequencer(self) -> None: ... 
	def addPositionKeyframe(self, frame: float, position: cave.Vector3) -> None: ... 
	def addRotationKeyframe(self, frame: float, rotator: cave.Quaternion) -> None: ... 
	def addScaleKeyframe(self, frame: float, scale: cave.Vector3) -> None: ... 
	def getPosition(self, frame: float) -> cave.Vector3: ... 
	def getRotation(self, frame: float) -> cave.Quaternion: ... 
	def getScale(self, frame: float) -> cave.Vector3: ... 
	def getFloorPositionAt(self, frame: float) -> cave.Vector3: ... 
	def getFloorRotationAt(self, frame: float) -> cave.Quaternion: ... 
	def getFloorScaleAt(self, frame: float) -> cave.Vector3: ... 
	def hasPositionKeyframes(self) -> bool: ... 
	def hasRotationKeyframes(self) -> bool: ... 
	def hasScaleKeyframes(self) -> bool: ... 


class Armature(Asset):
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def getBoundingBox(self, keepAspect: bool = True, transf: Transform = None) -> Transform: ... 
	def drawDebugLines(self, transform: Transform, scene: Scene, showParenting: bool = False) -> None: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def update(self, animation: Animation, frame: float, blend: float = 1, filter: AnimationFilter = None) -> None: ... 
	def addBone(self, boneName: str, bone: Bone) -> None: ... 
	def getBone(self, boneName: str, addIfNone: bool = False) -> Bone: ... 
	def getBones(self) -> List[Bone]: ... 
	def getBoneNames(self) -> List[str]: ... 
	def setBoneParent(self, child: str, parent: str) -> None: ... 


class Bone(NodeTransform):
	name: str 
	offset: cave.Matrix4 
	index: int 
	def getAnimatedMatrix(self) -> cave.Matrix4: ... 
	def setOffset(self, offset: cave.Matrix4) -> None: ... 
	def applyOffset(self) -> None: ... 
	def getOffset(self) -> cave.Matrix4: ... 
	def getIndex(self) -> int: ... 
	def setIndex(self, index: int) -> None: ... 
	def getChildren(self) -> List[Bone]: ... 


class Font(Asset):
	def __init__(self, resolution: int = 2048): ... 
	def buildAtlas(self, filePath: str) -> None: ... 
	def buildAtlas(self, data: int, size: int) -> None: ... 
	def exportTTF(self, filename: str) -> None: ... 
	def replaceTTF(self, filename: str) -> None: ... 
	def use(self, slot: int = 0) -> None: ... 
	def generateText(self, text: str, bindMesh: bool = True, scale: float = 1.0, spacing: float = 1) -> Mesh: ... 


class ColorSampler():
	def __init__(self): ... 
	def __init__(self, uniformName: str, uniformID: int): ... 
	def __init__(self, other: ColorSampler): ... 
	def init(self, uniformName: str, uniformID: int) -> None: ... 
	def use(self, shader: ShaderProgram) -> None: ... 
	def hasTexture(self) -> bool: ... 
	def getTextureName(self) -> str: ... 
	def getTexture(self, markAsDirty: bool = True) -> Texture: ... 
	def getColor(self) -> cave.Vector4: ... 
	def set(self, value: float) -> None: ... 
	def set(self, rgb: cave.Vector3, a: float = 1) -> None: ... 
	def set(self, rgba: cave.Vector4) -> None: ... 
	def set(self, r: float, g: float, b: float, a: float = 1) -> None: ... 
	def set(self, texture: str) -> None: ... 
	def set(self, texture: Texture) -> None: ... 


class Material(Asset):
	mask: BitMask 
	settings: MaterialUBO 
	backfaceCulling: bool 
	shaderOverride: AssetHandler[ShaderProgram] 
	uniforms: ShaderUniforms 
	def __init__(self, name: str = "Basic Material"): ... 
	def __init__(self, other: Material): ... 
	def uIDoubleClicked(self) -> None: ... 
	def use(self, _shader: ShaderProgram, shadowPass: bool = False) -> None: ... 
	def getShaderPermutations(self) -> int: ... 
	def generateDebugThumbnail(self, force: bool = False) -> None: ... 
	def isAlphaBlend(self) -> bool: ... 
	def isOpaque(self) -> bool: ... 
	def getCopy(self) -> Material: ... 
	def updateSettings(self) -> None: ... 
	def updateUniforms(self) -> None: ... 


class Sampler2D():
	texture: AssetHandler[Texture] 
	color: cave.Vector4 
	def __init__(self): ... 
	def __init__(self, _texture: Texture): ... 
	def __init__(self, textureName: str): ... 
	def __init__(self, r: float, g: float, b: float, a: float = 1): ... 
	def __init__(self, r: float, g: float, b: float, a: float, assetID: int): ... 
	def __init__(self, r: float, g: float, b: float, a: float, assetID: int, textureName: str): ... 
	def __init__(self, r: float, g: float, b: float, a: float, textureName: str): ... 
	def __init__(self, other: Sampler2D): ... 
	def asString(self) -> str: ... 
	def setTexture(self, tex: str) -> None: ... 
	def getTexture(self, stagingLocation: int, markAsDirty: bool = True) -> Texture: ... 
	def use(self, shader: ShaderProgram, uniform: str, location: int) -> None: ... 
	def drawTextureOnlyUI(self, samplerName: str, icon: str = ICON_FA_PALETTE) -> None: ... 
	def set(self, r: float, g: float, b: float, a: float = 1) -> None: ... 
	def set(self, value: float) -> None: ... 


class RenderableSun(Camera):
	color: cave.Vector3 
	intensity: float 
	shadow: ShadowSettings 
	hour: float 
	angle: float 
	def __init__(self): ... 
	def getProjection(self) -> cave.Matrix4: ... 
	def getDirection(self) -> cave.Vector3: ... 
	def getColor(self) -> cave.Vector3: ... 
	def getHour(self) -> float: ... 
	def setHour(self, value: float) -> None: ... 
	def getAngle(self) -> float: ... 
	def setAngle(self, value: float) -> None: ... 
	def alignTransformToView(self, cam: Camera) -> None: ... 


class RenderableSunShadowSettings():
	cast: bool 
	pcfSamples: int 
	pcfRadius: float 
	bias: float 
	influence: float 


class RenderGraph():
	sun: RenderableSun 
	config: Config 
	postProcessingOverride: AssetHandler[PostProcessing] 
	shaderProgramOverride: AssetHandler[ShaderProgram] 
	debug: DebugConfig 
	def __init__(self): ... 
	def updateRenderGraph(self, view: Camera) -> None: ... 
	def draw(self, view: Camera, defaultShader: ShaderProgram = None, opaquePass: bool = True, shadowPass: bool = False) -> None: ... 
	def drawDecals(self, s: ShaderProgram, plane: Mesh) -> None: ... 
	def getShaderPermutations(self, shadowPass: bool = False, opaquePass: bool = True) -> int: ... 
	def updateUniformBuffers(self, view: Camera) -> None: ... 
	def updateShaderUniforms(self, shader: ShaderProgram) -> None: ... 
	def getEntityFromLookup(self, pixelCoord: cave.IntVector4) -> Entity: ... 
	def getEntityLookup(self, entity: Entity) -> cave.IntVector4: ... 
	def getActiveEntityLookup(self) -> cave.IntVector4: ... 
	def setActiveEntity(self, shader: ShaderProgram) -> None: ... 
	def add(self, obj: MeshComponent) -> None: ... 
	def remove(self, obj: MeshComponent) -> bool: ... 
	def addProxy(self, obj: MeshProxyComponent) -> None: ... 
	def removeProxy(self, obj: MeshProxyComponent) -> None: ... 
	def addLight(self, obj: LightComponent) -> None: ... 
	def removeLight(self, obj: LightComponent) -> bool: ... 
	def addDecal(self, decal: DecalComponent) -> DecalComponent: ... 
	def removeDecal(self, decal: DecalComponent) -> bool: ... 


class RenderGraphConfig():
	applyShading: bool 
	ambient: Ambient 
	mist: Mist 
	sky: Sky 
	atmosphere: Atmosphere 
	background: cave.Vector3 
	ambientCol: cave.Vector3 
	ambientIntensity: float 


class RenderGraphConfigAmbient():
	use: bool 
	factor: float 
	color: ColorSampler 


class RenderGraphConfigMist():
	use: bool 
	start: float 
	distance: float 
	falloff: float 
	color: ColorSampler 


class RenderGraphConfigSky():
	blur: float 
	intensity: float 
	angle: float 
	color: ColorSampler 


class RenderGraphConfigAtmosphere():
	planetRadius: float 
	atmHeight: float 
	sunIntensity: float 


class RenderGraphDebugDrawPass():
	drawCalls: int 
	drawCallsInstanced: int 
	meshBindings: int 
	materialBindings: int 
	shaderBindings: int 
	drawnRenderables: int 
	culledRenderables: int 
	culledByDistance: int 
	vertices: int 
	triangles: int 


class RenderGraphDebugConfig():
	grid: bool 
	drawPassInfo: List[Tuple[str,DebugDrawPass]] 


class ImageTexture(Texture):
	def __init__(self): ... 
	def __init__(self, file: str): ... 
	def __init__(self, data: int, size: int): ... 
	def __init__(self, rgbaBitmap: int, width: int, height: int): ... 
	def __init__(self, other: ImageTexture): ... 
	def resize(self, newWidth: int, newHeight: int) -> bool: ... 
	def compressDXT(self) -> bool: ... 
	def getCopy(self) -> Texture: ... 


class UICanvas():
	def __init__(self): ... 
	def updateElements(self) -> None: ... 
	def draw(self) -> None: ... 
	def add(self, element: UIElementComponent) -> None: ... 
	def remove(self, element: UIElementComponent) -> None: ... 
	def getAll(self) -> List[UIElementComponent]: ... 


class UIRect():
	left: float 
	right: float 
	top: float 
	bottom: float 
	def __init__(self): ... 
	def __init__(self, l: float, r: float, t: float, b: float): ... 
	def isPointInside(self, point: cave.Vector2) -> bool: ... 
	def snapToGrid(self, gridSize: float = 0.05) -> None: ... 
	def getWidth(self) -> float: ... 
	def getHeight(self) -> float: ... 
	def getScale(self) -> cave.Vector2: ... 
	def getCenter(self) -> cave.Vector2: ... 


class UIVector():
	relativeX: bool 
	relativeY: bool 
	anchoring: cave.IntVector2 
	anchoringX: int 
	anchoringY: int 
	def __init__(self): ... 
	def __init__(self, other: UIVector): ... 
	def __init__(self, x: float, y: float): ... 
	def drawDebugUI(self, internalName: str, isScalingVec: bool = False) -> None: ... 
	def get(self, parentScale: cave.Vector2 = glm.vec2(1,1)) -> cave.Vector2: ... 
	def getX(self, parentScale: float = 1) -> float: ... 
	def getY(self, parentScale: float = 1) -> float: ... 
	def set(self, value: cave.Vector2, parentScale: cave.Vector2 = glm.vec2(1,1)) -> None: ... 
	def setPixelX(self, x: int) -> None: ... 
	def setPixelY(self, y: int) -> None: ... 
	def setRelativeX(self, x: float) -> None: ... 
	def setRelativeY(self, y: float) -> None: ... 
	def setPixel(self, x: int, y: int) -> None: ... 
	def setRelative(self, x: float, y: float) -> None: ... 
	def getAnchoringX(self) -> int: ... 
	def setAnchoringX(self, value: int) -> None: ... 
	def getAnchoringY(self) -> int: ... 
	def setAnchoringY(self, value: int) -> None: ... 
	def isRelativeX(self) -> bool: ... 
	def isRelativeY(self) -> bool: ... 
	def asString(self) -> str: ... 


class UIStyle(Asset):
	nineSliceUse: bool 
	nineSliceBorder: float 
	colorBase: Color 
	colorHovered: Color 
	colorPressed: Color 
	onHoverIn: SourceCode 
	onHoverOut: SourceCode 
	onClickIn: SourceCode 
	onClickOut: SourceCode 
	def __init__(self): ... 
	def __init__(self, other: UIStyle): ... 
	def uIDoubleClicked(self) -> None: ... 


class UIStyleColor():
	image: AssetHandler[Texture] 
	tint: cave.Vector3 
	alpha: float 
	blurBackground: float 
	def __init__(self): ... 


class SourceCode():

	# Enum: SourceCodeSourceType:# "SourceCode" class Enumeration.
	PYTHON : int 
	GLSL : int 

	source: str 
	def __str__(self) -> str: ...
	def __eq__(self, other) -> bool: ... # self == other
	def __eq__(self, other) -> bool: ... # self == other
	def __ne__(self, other) -> bool: ... # self != other
	def __ne__(self, other) -> bool: ... # self != other


class Timeline(Asset):

	# Enum: TimelineChannelBlend:# "Timeline" class Enumeration.
	BLEND_NONE : int 
	BLEND_LINEAR : int 
	BLEND_EASE : int 
	BLEND_QUADRIC : int 

	cameras: SortedFrames[Tuple[int,int]] 
	cameraNames: Dict[int,str] 
	callbacks: SortedFrames[SourceCode] 
	audioTracks: List[SortedFrames[AudioInstance]] 
	entities: List[Timeline.EntityChannel] 
	cursor: float 
	frameStart: float 
	frameEnd: float 
	def __init__(self): ... 
	def uIDoubleClicked(self) -> None: ... 
	def applyActiveCamera(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyActivityToEntities(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyFrameToEntities(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def applyAutoKeyframe(self, scene: Scene, frame: float, owner: Entity = None) -> None: ... 
	def getEntityChannel(self, ent: Entity, createIfNone: bool = True) -> Timeline.EntityChannel: ... 
	def getComponentChannel(self, ent: Entity, cmp: Component, createIfNone: bool = True) -> Timeline.ComponentChannel: ... 
	def getChannel(self, ent: Entity, cmp: Component, channel: str, createIfNone: bool = True) -> Timeline.Channel: ... 
	def isKeyframed(self, ent: Entity, cmp: Component, channel: str) -> bool: ... 


class TimelineChannel():
	blend: Timeline.ChannelBlend 
	def __init__(self): ... 
	def __init__(self, other: Timeline.Channel): ... 
	def setProp(self, propName: str) -> None: ... 
	def setProp(self, getterName: str, setterName: str) -> None: ... 
	def getValuePy(self, cmp: Component) -> py.object: ... 
	def setValuePy(self, cmp: Component, obj: py.object) -> None: ... 
	def findFloor(self, frame: float) -> int: ... 
	def findCeil(self, frame: float) -> int: ... 
	def getFrameValue(self, frame: float) -> py.object: ... 
	def getFrameValue(self, id: int) -> py.object: ... 
	def calculateFrame(self, frame: float, cmp: Component) -> None: ... 
	def applyAutoKeyframe(self, frame: float, cmp: Component) -> None: ... 
	def getFrames(self) -> List[Tuple[float,py.object]]: ... 
	def getNumFrames(self) -> int: ... 
	def set(self, frame: float, value: py.object, epsilon: float = 0.0001) -> None: ... 
	def set(self, id: int, value: py.object) -> None: ... 
	def getFrame(self, id: int) -> float: ... 
	def setFrame(self, id: int, newFrame: float) -> None: ... 
	def move(self, frame: float, newFrame: float, epsilon: float = 0.0001) -> bool: ... 
	def move(self, id: int, newFrame: float) -> bool: ... 
	def find(self, frame: float, epsilon: float = 0.0001) -> int: ... 
	def remove(self, id: int) -> None: ... 
	def sortFrames(self) -> None: ... 


class TimelineComponentChannel():
	id: int 
	localID: Tuple[str,int] 
	channels: Dict[str,Timeline.Channel] 
	def getComponent(self, ent: Entity) -> Component: ... 


class TimelineEntityChannel():
	id: int 
	nameID: str 
	components: List[Timeline.ComponentChannel] 
	def getEntity(self, scene: Scene, owner: Entity = None) -> Entity: ... 
	def isActive(self, frame: float) -> bool: ... 
	def getFrameID(self, frame: float) -> int: ... 
	def findFrameID(self, frame: float, epsilon: float = 0.0001) -> int: ... 
	def setActive(self, frame: float, active: bool) -> None: ... 
	def setActive(self, id: int, active: bool) -> None: ... 
	def remove(self, id: int) -> None: ... 
	def setFrame(self, id: int, newFrame: float) -> None: ... 
	def sortFrames(self) -> None: ... 
	def getActiveList(self) -> List[Tuple[float,bool]]: ... 


class TimelineAudioInstance():
	assetID: int 
	volume: float 
	pitch: float 
	start: float 
	end: float 


class TimelinePlayer():
	timeline: AssetHandler[Timeline] 
	frame: float 
	loop: bool 
	loops: int 
	playWhenPaused: bool 
	def __init__(self, _timeline: Timeline = None): ... 
	def isActive(self) -> bool: ... 
	def isFinished(self) -> bool: ... 
	def update(self, scene: Scene) -> None: ... 


class AnimationFilter():
	defaultBlend: float 
	blend: Dict[str,float] 
	def __init__(self, _defaultBlend: float = 0): ... 
	def __init__(self, other: AnimationFilter): ... 
	def setToBone(self, bone: Bone, value: float, recursive: bool = False) -> None: ... 
	def getBlend(self, boneName: str) -> float: ... 


class AnimationComponent(Component):
	armature: AssetHandler[Armature] 
	defaultAnimation: AssetHandler[Animation] 
	localBoundingBox: Transform 
	armatureBlock: ArmatureUBO 
	def __init__(self): ... 
	def __init__(self, other: AnimationComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def updateSockets(self) -> None: ... 
	def getWorldBoundingBox(self) -> Transform: ... 
	def playByName(self, anim: str, blend: float = 0, layer: int = 0, loop: bool = False, priority: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def play(self, anim: Animation, blend: float = 0, layer: int = 0, loop: bool = False, priority: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def getAnimation(self, layer: int = 0) -> AnimationComponent.AnimationLayer: ... 
	def getAnimationName(self, layer: int = 0) -> str: ... 
	def setLayerWeight(self, layer: int, value: float) -> None: ... 
	def getLayerWeight(self, layer: int) -> float: ... 
	def createLayerFilter(self, layer: int) -> AnimationFilter: ... 
	def copyLayerFilter(self, filter: AnimationFilter, layer: int) -> AnimationFilter: ... 
	def getLayerFilter(self, layer: int) -> AnimationFilter: ... 
	def removeLayerFilter(self, layer: int) -> None: ... 
	def stop(self, layer: int = 0) -> None: ... 
	def isLayerBlending(self, layer: int = 0) -> bool: ... 
	def getBlendingProgress(self, layer: int = 0) -> float: ... 
	def getRootMotion(self) -> cave.Vector3: ... 
	def getRootMotionLayer(self, layer: int = 0) -> cave.Vector3: ... 
	def addPostEvaluationCallback(self, function: py.object) -> None: ... 
	def clearPostEvaluationCallback(self) -> None: ... 


class AnimationComponentAnimationLayer():
	anim: AssetHandler[Animation] 
	frameCallbacks: List[int] 
	loop: bool 
	priority: int 
	loops: int 
	frame: float 
	speed: float 
	start: float 
	end: float 
	blendTimer: float 
	blendDuration: float 
	rootMotion: cave.Vector3 
	rootMotionLastPos: cave.Vector3 
	rootMotionLastLoopCount: int 
	rootMotionSkip: bool 
	def getName(self) -> str: ... 
	def getProgress(self) -> float: ... 


class AnimationSocketComponent(Component):
	boneName: str 
	position: CopyInfo 
	rotation: CopyInfo 
	scale: CopyInfo 
	def __init__(self): ... 
	def __init__(self, other: AnimationSocketComponent): ... 


class AnimationSocketComponentCopyInfo():
	copy: bool 
	offset: cave.Vector3 


class CameraComponent(Component):
	fov: float 
	clipStart: float 
	clipEnd: float 
	lerpPosition: float 
	lerpRotation: float 
	lerpFov: float 
	useCamera: bool 
	isPerspective: bool 
	updateWhenPaused: bool 
	flipX: bool 
	flipY: bool 
	def __init__(self): ... 
	def __init__(self, other: CameraComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def cameraUpdate(self) -> None: ... 
	def updateCamera(self, cam: Camera, applyLerp: bool = True) -> None: ... 
	def renderToTexture(self, textureName: str) -> None: ... 


class DecalComponent(Component):
	transform: TransformComponent 
	material: AssetHandler[Material] 
	overlayMask: BitMask 
	opacity: float 
	layer: int 
	angleFade: bool 
	projectionMode: int 
	def __init__(self): ... 
	def __init__(self, other: DecalComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def use(self, s: ShaderProgram) -> None: ... 
	def getMaterial(self, markAsDirty: bool = True) -> Material: ... 
	def setMaterial(self, asset: Material) -> None: ... 


class LightComponent(Component):
	color: cave.Vector3 
	radius: float 
	intensity: float 
	def __init__(self): ... 
	def __init__(self, other: LightComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 


class LogicBricksComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: LogicBricksComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 


class MeshComponent(Component):
	visible: bool 
	proxyForShadowPass: MeshProxyComponent 
	proxyForRegularPass: MeshProxyComponent 
	tint: cave.Vector4 
	mesh: AssetHandler[Mesh] 
	material: AssetHandler[Material] 
	allowUniformOverrides: bool 
	uniformOverrides: py.dict 
	def __init__(self): ... 
	def __init__(self, other: MeshComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCustomName(self) -> str: ... 
	def getBoundingBox(self, keepAspect: bool = True) -> Transform: ... 
	def isAlphaBlend(self) -> bool: ... 
	def isOpaque(self) -> bool: ... 
	def getFinalMaterial(self) -> Material: ... 


class MeshProxyComponent(MeshComponent):

	# Enum: MeshProxyComponentPassMask:# "MeshProxyComponent" class Enumeration.
	ALL_PASSES : int 
	SHADOW_PASS : int 
	REGULAR_PASS : int 

	settings: ProxyMeshSettings 
	def __init__(self): ... 
	def __init__(self, other: MeshProxyComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getCustomName(self) -> str: ... 
	def updateProxies(self, view: Camera, passMask: MeshProxyComponent.PassMask = MeshProxyComponent.PassMask.REGULAR_PASS) -> None: ... 
	def bakeProxyMesh(self) -> None: ... 
	def exportMeshesToBakeAsObj(self) -> None: ... 


class MeshProxyComponentProxyMeshSettings():
	proxyDistance: float 
	decimation: float 
	removeDoubles: bool 
	ignoreUVs: bool 
	passFilter: PassMask 
	skipDynamicRbs: bool 
	skipPythonCmps: bool 
	skipTemplates: bool 
	materialFilter: AssetHandler[Material] 
	useHighestLOD: bool 


class ParticleInstance():
	life: float 
	transform: NodeTransform 
	linearVelocity: cave.Vector3 
	angularVelocity: cave.Vector3 


class ParticleComponent(MeshComponent):
	optimization: Optimizations 
	instanceSetting: ParticleInstanceDescriptor 
	instanceLifeColors: CurveColors 
	instanceSpawn: AssetHandler[Mesh] 
	emmiterLifetime: SceneTimer 
	def __init__(self): ... 
	def __init__(self, other: ParticleComponent): ... 
	def getCustomName(self) -> str: ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getParticleCount(self) -> int: ... 
	def getTransforms(self) -> List[Transform]: ... 
	def getTints(self) -> List[cave.Vector4]: ... 


class ParticleComponentOptimizations():
	cullDistance: float 
	frameSkips: int 


class ParticleComponentParticleInstanceDescriptor():
	count: int 
	spawnArea: cave.Vector3 
	scaleMin: cave.Vector3 
	scaleMax: cave.Vector3 
	rotationMin: cave.Vector3 
	rotationMax: cave.Vector3 
	isDynamic: bool 
	useParent: bool 
	life: float 
	respawn: float 
	gravity: cave.Vector3 
	linearVelocity: cave.Vector3 
	linearConservation: cave.Vector3 
	angularVelocity: cave.Vector3 
	angularConservation: cave.Vector3 


class ParticleComponentCurveColors():
	r: Curve 
	g: Curve 
	b: Curve 
	a: Curve 


class PythonCodeComponent(Component):

	# Enum: PythonCodeComponentOptimizationPolicy:# "PythonCodeComponent" class Enumeration.
	NO_OPTIMIZATION : int 
	DISTANCE_CULLING : int 
	FRAME_SKIPPING : int 

	optimization: Optimizations 
	code: PyCodes 
	properties: py.dict 
	def __init__(self): ... 
	def __init__(self, other: PythonCodeComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def compileScripts(self) -> None: ... 


class PythonCodeComponentOptimizations():
	policy: OptimizationPolicy 
	cullDistance: float 
	executionInterval: float 
	executionTimer: Timer 
	applyToUpdate: bool 
	applyToPausedUpdate: bool 
	applyToEditorUpdate: bool 


class PythonCodeComponentPyCodes():


class PythonComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: PythonComponent): ... 
	def getCustomName(self) -> str: ... 
	def start(self, s: Scene) -> None: ... 
	def firstUpdate(self) -> None: ... 
	def update(self) -> None: ... 
	def pausedUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCastedPy(self) -> Component: ... 
	def getClassName(self) -> str: ... 


class TransformComponent(Component, NodeTransform):
	def __init__(self): ... 
	def __init__(self, other: TransformComponent): ... 
	def getParent(self) -> NodeTransform: ... 


class FirstPersonCamComponent(MouselookComponent):
	def __init__(self): ... 
	def __init__(self, other: FirstPersonCamComponent): ... 
	def start(self, scene: Scene) -> None: ... 


class ThirdPersonCamComponent(Component):

	# Enum: ThirdPersonCamComponentAlignPlayerRule:# "ThirdPersonCamComponent" class Enumeration.
	NEVER : int 
	ON_MOVEMENT : int 
	ALWAYS : int 

	mouselook: Mouselook 
	alignPlayer: AlignPlayerRule 
	alignSmooth: float 
	headOffset: cave.Vector3 
	cameraOffset: Transform 
	camCollision: CamCollisionConfig 
	def __init__(self): ... 
	def __init__(self, other: ThirdPersonCamComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def enableJoystick(self, id: int, tolerance: float = 0.1, sensitivity: cave.Vector2 = glm.vec2(-0.1,0.1)) -> None: ... 
	def disableJoystick(self) -> None: ... 
	def isJoystickEnabled(self) -> bool: ... 


class ThirdPersonCamComponentMouselook():
	sensitivity: cave.Vector2 
	threshold: cave.Vector2 
	pitchLimit: cave.Vector2 


class ThirdPersonCamComponentCamCollisionConfig():
	use: bool 
	radius: float 
	mask: BitMask 


class TopDownCamComponent(Component):
	playerName: str 
	height: float 
	distance: float 
	onGroundOnly: bool 
	forwardAdvance: float 
	def __init__(self): ... 
	def __init__(self, other: TopDownCamComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def lateUpdate(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def getTargetPosition(self) -> cave.Vector3: ... 
	def getExpectedCamPositionFor(self, playerPos: cave.Vector3) -> cave.Vector3: ... 


class AudioComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: AudioComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 


class MouselookAxisConfig():
	use: bool 
	rotationLocal: bool 
	rotationAxis: int 
	rangeMin: float 
	rangeMax: float 
	sensitivity: float 
	threshold: float 
	m_allowRotationAdjust: bool 


class MouselookComponent(Component):
	lockMousePos: bool 
	xAxis: MouselookAxisConfig 
	yAxis: MouselookAxisConfig 
	def __init__(self): ... 
	def __init__(self, other: MouselookComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 


class PlayerComponent(Component):
	active: bool 
	smoothTurn: float 
	smoothSpeed: float 
	walkSpeed: float 
	runSpeed: float 
	localMovement: bool 
	jump: bool 
	def __init__(self): ... 
	def __init__(self, other: PlayerComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def isWalking(self) -> bool: ... 
	def isRunning(self) -> bool: ... 


class VehicleControllerComponent(Component):
	active: bool 
	def __init__(self): ... 
	def __init__(self, other: VehicleControllerComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 


class UIElementComponent(Component):

	# Enum: UIElementComponentStatus:# "UIElementComponent" class Enumeration.
	NORMAL : int 
	HOVERED : int 
	PRESSED : int 

	position: UIVector 
	scale: UIVector 
	layer: int 
	quad: QuadDesc 
	font: FontDesc 
	defaultQuadAlpha: float 
	defaultQuadColor: cave.Vector3 
	defaultQuadBlurBackground: float 
	def __init__(self): ... 
	def __init__(self, other: UIElementComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getParent(self) -> UIElementComponent: ... 
	def getChildren(self) -> List[UIElementComponent]: ... 
	def getText(self) -> str: ... 
	def setText(self, value: str) -> None: ... 
	def isHovered(self) -> bool: ... 
	def isPressed(self) -> bool: ... 
	def getDrawFontScale(self) -> cave.Vector2: ... 
	def getDefaultQuadAlpha(self) -> float: ... 
	def setDefaultQuadAlpha(self, value: float) -> None: ... 
	def getDefaultQuadColor(self) -> cave.Vector3: ... 
	def setDefaultQuadColor(self, color: cave.Vector3) -> None: ... 
	def getDefaultQuadBlurBackground(self) -> float: ... 
	def setDefaultQuadBlurBackground(self, value: float) -> None: ... 


class UIElementComponentQuadDesc():
	style: UIStyle 
	styleOverride: AssetHandler[UIStyle] 
	hoverable: bool 
	clickable: bool 


class UIElementComponentFontConfig():
	scale: float 
	spacing: float 
	hScale: float 
	lineHeight: float 
	textAlign: int 
	textAnchor: int 


class UIElementComponentFontDesc():
	source: AssetHandler[Font] 
	config: FontConfig 
	text: str 


class CharacterComponent(Component):
	shape: ShapeDesc 
	config: Config 
	group: BitMask 
	mask: BitMask 
	verticalVelocity: float 
	fallSpeed: float 
	gravity: float 
	jumpSpeed: float 
	maxSlope: float 
	enabled: bool 
	def __init__(self): ... 
	def __init__(self, other: CharacterComponent): ... 
	def getVerticalVelocity(self) -> float: ... 
	def setVerticalVelocity(self, val: float) -> None: ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def getCollisions(self) -> List[CollisionInfo]: ... 
	def getCollisionsWith(self, tag: str) -> List[CollisionInfo]: ... 
	def collidedWith(self, tag: str) -> bool: ... 
	def getTransformFromBullet(self) -> None: ... 
	def sendTransformToBullet(self) -> None: ... 
	def getFallSpeed(self) -> float: ... 
	def setFallSpeed(self, value: float) -> None: ... 
	def getCurrentFallSpeed(self) -> float: ... 
	def getGravity(self) -> float: ... 
	def setGravity(self, value: float) -> None: ... 
	def getJumpSpeed(self) -> float: ... 
	def setJumpSpeed(self, value: float) -> None: ... 
	def getMaxSlope(self) -> float: ... 
	def setMaxSlope(self, value: float) -> None: ... 
	def jump(self) -> None: ... 
	def setWalkDirection(self, x: float, y: float, z: float, local: bool = True) -> None: ... 
	def setWalkDirection(self, dir: cave.Vector3, local: bool = True) -> None: ... 
	def getWalkDirection(self, ignoreDeltaTime: bool = False) -> cave.Vector3: ... 
	def getMoveSpeed(self, ignoreDeltaTime: bool = False) -> float: ... 
	def isMoving(self) -> bool: ... 
	def isFalling(self) -> bool: ... 
	def onGround(self) -> bool: ... 
	def reset(self) -> None: ... 
	def isEnabled(self) -> bool: ... 
	def enable(self) -> None: ... 
	def disable(self) -> None: ... 
	def setEnabled(self, value: bool) -> None: ... 
	def getEnabled(self) -> bool: ... 


class CharacterComponentShapeDesc():
	height: float 
	radius: float 


class CharacterComponentConfig():
	fallSpeed: float 
	gravity: float 
	jumpSpeed: float 
	jumpHeight: float 
	maxSlope: float 



# Enum: PhysicsConstraintType: 
HINGE : int 
SLIDER : int 
SPHERE : int 

class PhysicsConstraintComponent(Component):
	def __init__(self): ... 
	def __init__(self, other: PhysicsConstraintComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def setType(self, type: PhysicsConstraintType) -> None: ... 



# Enum: RigidBodyShape: 
CONVEX_HULL : int 
TRIANGLE_MESH : int 
BOUNDING_BOX : int 

class RigidBodyComponent(Component):
	mesh: AssetHandler[Mesh] 
	alwaysActive: bool 
	enableDistanceCulling: bool 
	cullDistance: float 
	group: BitMask 
	mask: BitMask 
	angularFactor: cave.Vector3 
	shapeType: RigidBodyShape 
	ghost: bool 
	def __init__(self): ... 
	def __init__(self, other: RigidBodyComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def update(self) -> None: ... 
	def end(self, s: Scene) -> None: ... 
	def getCollisions(self) -> List[CollisionInfo]: ... 
	def getCollisionsWith(self, tag: str) -> List[CollisionInfo]: ... 
	def collidedWith(self, tag: str) -> bool: ... 
	def getCustomName(self) -> str: ... 
	def getTransformFromBullet(self) -> None: ... 
	def sendTransformToBullet(self) -> None: ... 
	def applyTorque(self, x: float, y: float, z: float) -> None: ... 
	def applyForce(self, x: float, y: float, z: float, location: cave.Vector3) -> None: ... 
	def applyImpulse(self, x: float, y: float, z: float, location: cave.Vector3) -> None: ... 
	def setLinearVelocity(self, x: float, y: float, z: float) -> None: ... 
	def getLinearVelocity(self) -> cave.Vector3: ... 
	def setAngularVelocity(self, x: float, y: float, z: float) -> None: ... 
	def getAngularVelocity(self) -> cave.Vector3: ... 
	def setMass(self, mass: float) -> None: ... 
	def setAngularFactor(self, value: cave.Vector3) -> None: ... 
	def setAngularFactor(self, x: float, y: float, z: float) -> None: ... 
	def getAngularFactor(self) -> cave.Vector3: ... 
	def setShapeType(self, shape: RigidBodyShape) -> None: ... 
	def getShapeType(self) -> RigidBodyShape: ... 
	def getShapeType(self) -> RigidBodyShape: ... 
	def isDynamic(self) -> bool: ... 
	def isBoxCollider(self) -> bool: ... 
	def getBoxOffset(self) -> cave.Vector3: ... 
	def getBoxScale(self) -> cave.Vector3: ... 
	def isGhost(self) -> bool: ... 
	def getGhost(self) -> bool: ... 
	def setGhost(self, value: bool) -> None: ... 
	def getTriangleMeshTriangleCount(self) -> int: ... 


class VehicleComponent(Component):
	engineForce: Engine 
	steering: Steering 
	def __init__(self): ... 
	def __init__(self, other: VehicleComponent): ... 
	def start(self, scene: Scene) -> None: ... 
	def update(self) -> None: ... 
	def end(self, scene: Scene) -> None: ... 
	def accelerate(self, scale: float = 1) -> None: ... 
	def reverse(self, scale: float = 1) -> None: ... 
	def brake(self, scale: float = 1) -> None: ... 
	def brakeRelease(self) -> None: ... 
	def idle(self) -> None: ... 
	def applyForce(self, force: float) -> None: ... 
	def turnLeft(self) -> None: ... 
	def turnRight(self) -> None: ... 
	def turnStraight(self) -> None: ... 


class VehicleComponentEngine():
	acceleration: float 
	reverse: float 
	brake: float 


class VehicleComponentSteering():
	clamp: float 
	increment: float 


class WheelComponent(Component):
	tuning: TuningConfig 
	control: Controls 
	dirAxis: int 
	axleAxis: int 
	suspensionRestLength: float 
	radius: float 
	isFrontWheel: bool 
	def __init__(self): ... 
	def __init__(self, other: WheelComponent): ... 
	def start(self, s: Scene) -> None: ... 
	def editorUpdate(self) -> None: ... 
	def getDirection(self) -> cave.Vector3: ... 
	def getAxle(self) -> cave.Vector3: ... 


class WheelComponentTuningConfig():
	suspensionStiffness: float 
	suspensionCompression: float 
	suspensionDamping: float 
	suspensionTravelCmMax: float 
	suspensionForceMax: float 
	frictionSlip: float 


class WheelComponentControls():
	hasTraction: bool 
	hasBrake: bool 



def tintValue(value: float, minV: float, maxV: float) -> bool: ... 
def tintClear() -> None: ... 

class Profiler():
	maxFrameCount: int 
	def __init__(self): ... 
	def startFrame(self) -> None: ... 
	def endFrame(self) -> None: ... 
	def dumpProfilerLog(self) -> None: ... 
	def getFrameTimes(self) -> List[float]: ... 
	def push(self, name: str) -> Profiler.Scope: ... 
	def pop(self, scope: Profiler.Scope) -> None: ... 
	def getCurrent(self) -> Profiler.Scope: ... 
	def getScopeTraceBack(self, maxTraceBack: int = 6) -> str: ... 


class ProfilerScope():
	name: str 
	start: TimeStructure 
	end: TimeStructure 
	parent: Scope 
	children: List[Scope] 
	def __init__(self): ... 
	def getDump(self) -> str: ... 
	def drawBarsUI(self, startX: float, endX: float, removeOutsideTime: bool = False) -> None: ... 


class ScopedProfiler():
	def __init__(self, name: str, active: bool = True): ... 
	def addNote(self, note: str, value: str = "") -> None: ... 
	def setName(self, name: str) -> None: ... 


class BitMask():
	def __init__(self, enableFirstEight: bool = True): ... 
	def __init__(self, other: BitMask): ... 
	def intersect(self, other: BitMask) -> bool: ... 
	def isEnabled(self, n: int) -> bool: ... 
	def get(self, n: int) -> bool: ... 
	def set(self, n: int, value: bool) -> None: ... 
	def enable(self, n: int) -> None: ... 
	def disable(self, n: int) -> None: ... 
	def enableAll(self) -> None: ... 
	def disableAll(self) -> None: ... 
	def getUInt(self) -> int: ... 
	def getFloat(self) -> float: ... 



def lerpVec3Linear(start: cave.Vector3, end: cave.Vector3, amount: float) -> cave.Vector3: ... 
def lerpQuatLinear(start: cave.Quaternion, end: cave.Quaternion, amount: float) -> cave.Quaternion: ... 
def lerpVec3Constant(start: cave.Vector3, end: cave.Vector3, amount: float) -> cave.Vector3: ... 
def lerpQuatConstant(start: cave.Quaternion, end: cave.Quaternion, amount: float) -> cave.Quaternion: ... 

class Curve():
	def __init__(self): ... 
	def __init__(self, other: Curve): ... 
	def setAll(self, value: float) -> None: ... 
	def set(self, value: float) -> None: ... 
	def get(self, position: float) -> float: ... 


class NodeTransform(Transform):
	worldMatrix: cave.Matrix4 
	worldPosition: cave.Vector3 
	def __init__(self): ... 
	def __init__(self, other: NodeTransform): ... 
	def getWorldMatrix(self) -> cave.Matrix4: ... 
	def getInverseWorldMatrix(self) -> cave.Matrix4: ... 
	def getWorldRotator(self) -> cave.Matrix3: ... 
	def setWorldMatrix(self, matrix: cave.Matrix4) -> None: ... 
	def getWorldPosition(self) -> cave.Vector3: ... 
	def setWorldPosition(self, pos: cave.Vector3) -> None: ... 
	def setWorldPosition(self, x: float, y: float, z: float) -> None: ... 
	def getWorldEuler(self) -> cave.Vector3: ... 
	def getWorldQuaternion(self) -> cave.Quaternion: ... 
	def lookAt(self, direction: cave.Vector3, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def lookAtSmooth(self, direction: cave.Vector3, lerp: float = 0.5, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def setParent(self, parent: NodeTransform, keepTransform: bool = False) -> None: ... 
	def removeParent(self) -> None: ... 
	def getParent(self) -> NodeTransform: ... 
	def addChildren(self, children: NodeTransform) -> None: ... 
	def removeChildren(self, children: NodeTransform) -> None: ... 



def toRadians(degreeAngle: float) -> float: ... 
def toDegrees(radiansAngle: float) -> float: ... 

class Transform():
	worldMatrix: cave.Matrix4 
	rotator: cave.Matrix3 
	matrix: cave.Matrix4 
	def __init__(self): ... 
	def __init__(self, other: Transform): ... 
	def set(self, other: Transform) -> None: ... 
	def getWorldMatrix(self) -> cave.Matrix4: ... 
	def getInverseWorldMatrix(self) -> cave.Matrix4: ... 
	def getWorldRotator(self) -> cave.Matrix3: ... 
	def setWorldMatrix(self, matrix: cave.Matrix4) -> None: ... 
	def applyTransform(self, other: Transform) -> None: ... 
	def getWorldPosition(self) -> cave.Vector3: ... 
	def getPosition(self) -> cave.Vector3: ... 
	def setPosition(self, x: float, y: float, z: float) -> None: ... 
	def setPosition(self, position: cave.Vector3) -> None: ... 
	def getPositionCopy(self) -> cave.Vector3: ... 
	def applyMovement(self, x: float, y: float, z: float) -> None: ... 
	def applyMovement(self, position: cave.Vector3) -> None: ... 
	def applyLocalMovement(self, x: float, y: float, z: float) -> None: ... 
	def applyLocalMovement(self, movement: cave.Vector3) -> None: ... 
	def lookAt(self, direction: cave.Vector3, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def lookAtSmooth(self, direction: cave.Vector3, lerp: float = 0.5, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def lookAtPosition(self, position: cave.Vector3, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def lookAtPositionSmooth(self, position: cave.Vector3, lerp: float = 0.5, up: cave.Vector3 = glm.vec3(0,1,0)) -> None: ... 
	def lerp(self, target: Transform, lerp: float = 0.5) -> None: ... 
	def sLerpQuaternion(self, target: cave.Quaternion, lerp: float = 0.5) -> None: ... 
	def getQuaternion(self) -> cave.Quaternion: ... 
	def setQuaternion(self, x: float, y: float, z: float, w: float) -> None: ... 
	def setQuaternion(self, quaternion: cave.Quaternion) -> None: ... 
	def getEuler(self) -> cave.Vector3: ... 
	def setEuler(self, x: float, y: float, z: float) -> None: ... 
	def setEuler(self, euler: cave.Vector3) -> None: ... 
	def getRotator(self) -> cave.Matrix3: ... 
	def setRotator(self, rotator: cave.Matrix3) -> None: ... 
	def rotateVector(self, vec: cave.Vector3) -> cave.Vector3: ... 
	def unrotateVector(self, vec: cave.Vector3) -> cave.Vector3: ... 
	def transformVector(self, vec: cave.Vector3) -> cave.Vector3: ... 
	def untransformVector(self, vec: cave.Vector3) -> cave.Vector3: ... 
	def transformDirection(self, dir: cave.Vector3) -> cave.Vector3: ... 
	def untransformDirection(self, dir: cave.Vector3) -> cave.Vector3: ... 
	def getScale(self) -> cave.Vector3: ... 
	def getWorldScale(self) -> cave.Vector3: ... 
	def setScale(self, scalar: float) -> None: ... 
	def setScale(self, x: float, y: float, z: float) -> None: ... 
	def setScale(self, scale: cave.Vector3) -> None: ... 
	def getMatrix(self) -> cave.Matrix4: ... 
	def getInverseMatrix(self) -> cave.Matrix4: ... 
	def setMatrix(self, matrix: cave.Matrix4) -> None: ... 
	def getRotationMatrix(self) -> cave.Matrix4: ... 
	def getPitch(self) -> float: ... 
	def getYaw(self) -> float: ... 
	def getRoll(self) -> float: ... 
	def getForwardVector(self, world: bool = False) -> cave.Vector3: ... 
	def getRightVector(self, world: bool = False) -> cave.Vector3: ... 
	def getUpVector(self, world: bool = False) -> cave.Vector3: ... 
	def move(self, x: float, y: float, z: float, local: bool = True) -> None: ... 
	def rotate(self, x: float, y: float, z: float) -> None: ... 
	def rotateEuler(self, x: float, y: float, z: float) -> None: ... 
	def rotateOnAxis(self, angle: float, axis: cave.Vector3) -> None: ... 
	def rotateOnPitch(self, angle: float) -> None: ... 
	def rotateOnYaw(self, angle: float) -> None: ... 
	def rotateOnRoll(self, angle: float) -> None: ... 


class CollisionInfo():
	position: cave.Vector3 
	normal: cave.Vector3 
	entity: Entity 


class PhysicsMesh():
	def __init__(self, mesh: Mesh): ... 
	def getPrimitiveInfo(self) -> Transform: ... 
	def getTriangleCount(self) -> int: ... 
	def getMeshOwner(self) -> Mesh: ... 
	def hasMeshOwner(self) -> bool: ... 


class RayCastOut():
	hit: bool 
	position: cave.Vector3 
	normal: cave.Vector3 
	entity: Entity 
	def __init__(self): ... 


class SphereCastOut(RayCastOut):
	penetration: float 
	recoveryPosition: cave.Vector3 
	def __init__(self): ... 


class PhysicsWorld():
	def __init__(self): ... 
	def update(self) -> None: ... 
	def drawDebug(self) -> None: ... 
	def rayCast(self, origin: cave.Vector3, target: cave.Vector3, mask: BitMask = BitMask()) -> RayCastOut: ... 
	def rayCastAll(self, origin: cave.Vector3, target: cave.Vector3, mask: BitMask = BitMask()) -> List[RayCastOut]: ... 
	def sphereCast(self, origin: cave.Vector3, target: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastEntity(self, ignoreEntity: Entity, origin: cave.Vector3, target: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> SphereCastOut: ... 
	def sphereCastAll(self, origin: cave.Vector3, target: cave.Vector3, radius: float, mask: BitMask = BitMask()) -> List[SphereCastOut]: ... 
	def checkContactBox(self, box: Transform, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... 
	def checkContactSphere(self, box: Transform, radius: float, mask: BitMask = BitMask()) -> List[CollisionInfo]: ... 
	def addRigidBody(self, body: RigidBodyComponent) -> None: ... 
	def removeRigidBody(self, body: RigidBodyComponent) -> None: ... 
	def addConstraint(self, constraint: PhysicsConstraintComponent) -> None: ... 
	def removeConstraint(self, constraint: PhysicsConstraintComponent) -> None: ... 
	def addCharacter(self, character: CharacterComponent) -> None: ... 
	def removeCharacter(self, character: CharacterComponent) -> None: ... 
	def getCollisionsWith(self, body: RigidBodyComponent) -> List[CollisionInfo]: ... 
	def getCollisionsWith(self, body: CharacterComponent) -> List[CollisionInfo]: ... 
	def getDebugInfo(self) -> PhysicsWorld.PhysicsWorldDebugInfo: ... 


class PhysicsWorldPhysicsWorldDebugInfo():
	numBodies: int 
	ghostBodies: int 
	staticBodies: int 
	dynamicBodies: int 
	shapeConvexHull: int 
	shapeBoundingBox: int 
	shapeTriangleMesh: int 
	triangleMeshPolyCount: int 
	triangleMeshEntities: List[Tuple[Entity,int]] 
	numCharacters: int 
	numCollisionObjects: int 
	numConstraints: int 


class App():
	avgTime: float 
	profiler: Profiler 
	renderer: Renderer 
	config: AppDebugConfig 
	performanceEmulator: PerformanceEmulator 
	debugUI: DebugUI 
	def showLoadingScreen(self) -> None: ... 
	def hideLoadingScreen(self) -> None: ... 
	def run(self) -> None: ... 
	def loadGameAssetsFromDisk(self, separateFiles: bool = True) -> None: ... 
	def reloadGameAssetsFromDisk(self, separateFiles: bool = True) -> None: ... 
	def getDeltaTime(self) -> float: ... 
	def getFPS(self) -> int: ... 
	def restartCurrentScene(self) -> None: ... 
	def setScene(self, scene: Scene, forceDirty: bool = False) -> None: ... 
	def setSceneQueued(self, scene: Scene) -> None: ... 
	def getScene(self) -> Scene: ... 
	def getAssetData(self) -> AssetData: ... 
	def getEvents(self) -> Events: ... 
	def getWindow(self) -> Window: ... 
	def getPythonEnv(self) -> PythonEnv: ... 
	def getRenderAspect(self) -> float: ... 
	def setGamePath(self, path: str) -> None: ... 
	def getGamePath(self, localPath: str) -> str: ... 
	def getGameName(self) -> str: ... 
	def setDebugUI(self) -> None: ... 
	def setDebugUI(self, ui: DebugUI) -> None: ... 
	def getDebugUI(self) -> DebugUI: ... 
	def getMousePosition(self) -> cave.Vector2: ... 
	def enableGameLogic(self) -> None: ... 
	def disableGameLogic(self) -> None: ... 
	def isGameLogicEnabled(self) -> bool: ... 
	def loadPythonScripts(self) -> None: ... 
	def getCurrentFrameNumber(self) -> int: ... 


class AppAppDebugConfig():
	debugPhysics: bool 
	debugPhysicsConfig: DebugPhysicsConfig 
	debugLines: bool 
	debugPlaySound: bool 
	debugUseMist: bool 
	debugApplyPostProcessing: bool 
	showGameUI: bool 


class AppAppDebugConfigDebugPhysicsConfig():
	drawWireframe: bool 
	drawAabb: bool 
	drawFeaturesText: bool 
	drawContactPoints: bool 
	noDeactivation: bool 
	noHelpText: bool 
	drawText: bool 
	profileTimings: bool 
	enableSatComparison: bool 
	disableBulletLCP: bool 
	enableCCD: bool 
	drawConstraints: bool 
	drawConstaintsLimits: bool 
	fastWireframe: bool 
	drawNormals: bool 


class AppPerformanceEmulator():
	active: bool 
	minFrameCostMs: float 
	maxFrameCostMs: float 


class CaveException():
	def __init__(self, message: str, file: str = "", line: int = 0): ... 
	def __init__(self, other: CaveException): ... 
	def what(self, withStackTrace: bool = True) -> str: ... 



def hideConsole() -> None: ... 
def showConsole() -> None: ... 
def isConsoleVisible() -> bool: ... 
def showProgressBar(title: str, maxValue: int = 100) -> None: ... 
def hideProgressBar() -> None: ... 
def updateProgressBar(value: int) -> None: ... 
def incrementProgressBar() -> None: ... 
def incrementProgressBarWith(value: int) -> None: ... 
def setProgressBar(value: int, maxValue: int) -> None: ... 
def showErrorMessage(title: str, body: str) -> None: ... 
def showWarningMessage(title: str, body: str) -> None: ... 
def showInfoMessage(title: str, body: str) -> None: ... 
def showQuestionMessage(title: str, body: str) -> bool: ... 
def notify(title: str, text: str) -> None: ... 
def selectFolder(title: str, defaultPath: str, forcePath: bool = False) -> str: ... 


def revealInExplorer(path: str) -> None: ... 
def open(path: str, mode: str) -> FILE: ... 
def getBasePath() -> str: ... 
def getEditorPath(localPath: str) -> str: ... 
def getEditorDataPath(localPath: str) -> str: ... 
def getSystemDataPath(localPath: str) -> str: ... 
def splitPath(path: str) -> List[str]: ... 
def isFolder(path: str) -> bool: ... 
def join(path: str, file: str) -> str: ... 
def getOSPath(path: str) -> str: ... 
def getFileExtension(filePath: str) -> str: ... 
def getFileName(filePath: str) -> str: ... 
def getFileFolderPath(filePath: str) -> str: ... 
def getLastWriteDate(file: str) -> str: ... 
def getLastWriteTime(file: str) -> time_t: ... 
def countFilesWithExtensionAt(path: str, extension: str) -> int: ... 
def timeToDate(time: time_t) -> str: ... 
def exists(filePath: str) -> bool: ... 
def createPath(path: str) -> None: ... 
def duplicate(file: str, target: str) -> None: ... 
def getFilesAt(path: str) -> List[str]: ... 
def remove(path: str) -> bool: ... 
def removeAll(path: str) -> bool: ... 
def dumpToMemory(path: str, length: int, useNewOperator: bool = True) -> int: ... 
def read(file: str) -> str: ... 
def write(file: str, text: str) -> None: ... 


def sendToApp(message: str) -> bool: ... 
def message(title: str, body: str, icon: str = "") -> None: ... 
def fileLogInit() -> None: ... 
def fileLogShutdown() -> None: ... 
def fileLogEnableGlCallback() -> None: ... 
def fileLogMessage(message: str) -> None: ... 

class ProgressBar():
	def __init__(self, title: str, maxValue: int = 100): ... 
	def update(self, progress: int) -> None: ... 
	def increment(self) -> None: ... 
	def add(self, value: int) -> None: ... 
	def set(self, value: int, maxValue: int) -> None: ... 


class ThreadPool():
	def __init__(self, numThreads: int): ... 
	def __init__(self, other: ThreadPool): ... 
	def enqueue(self, task: ThreadPool.Task) -> None: ... 
	def waitAll(self) -> None: ... 
	def getThreadCount(self) -> int: ... 


class Version():
	major: int 
	minor: int 
	patch: int 
	pro: bool 
	def __init__(self): ... 
	def __init__(self, major: int, minor: int, patch: int): ... 
	def __init__(self, other: Version): ... 
	def getVersionStr(self) -> str: ... 
	def isCompatible(self, other: Version, breakPath: bool = False) -> bool: ... 
	def __eq__(self, other) -> bool: ... # self == other
	def __gt__(self, other) -> bool: ... # self > other
	def __lt__(self, other) -> bool: ... # self < other
	def __ge__(self, other) -> bool: ... # self >= other
	def __le__(self, other) -> bool: ... # self <= other


class Window():

	# Enum: WindowType:# "Window" class Enumeration.
	CUSTOM : int 
	MAXIMIZED : int 
	FULLSCREEN : int 

	def setTitle(self, title: str) -> None: ... # Changes the Window title.
	def getTitle(self) -> str: ... # Returns the window Title
	def getAspect(self) -> float: ... 
	def getWindowPosition(self) -> cave.Vector2: ... 
	def getWindowSize(self) -> cave.Vector2: ... 
	def setMousePosition(self, x: int, y: int) -> None: ... 
	def setMousePositionX(self, value: int) -> None: ... 
	def setMousePositionY(self, value: int) -> None: ... 
	def getMousePosition(self, normalize: bool = False) -> cave.Vector2: ... 
	def setFullscreen(self, value: bool) -> None: ... 
	def toggleFullscreen(self) -> None: ... 
	def isFullscreen(self) -> bool: ... 
	def isMaximized(self) -> bool: ... 
	def isMinimized(self) -> bool: ... 
	def hasInputFocus(self) -> bool: ... 
	def hasMouseFocus(self) -> bool: ... 
	def isShown(self) -> bool: ... 
	def isHidden(self) -> bool: ... 
	def minimize(self) -> None: ... 
	def maximize(self) -> None: ... 
	def restore(self) -> None: ... 
	def hide(self) -> None: ... 
	def show(self) -> None: ... 


class File():

	# Enum: FileFileMode:# "File" class Enumeration.
	READ : int 
	WRITE : int 

	seek: int 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def getPath(self) -> str: ... 
	def isValid(self) -> bool: ... 
	def getHeader(self) -> Version: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def read(self, buffer: str) -> bool: ... 
	def write(self, buffer: str) -> bool: ... 
	def read(self, src: SourceCode) -> bool: ... 
	def write(self, src: SourceCode) -> bool: ... 
	def readStr(self, buffer: str) -> bool: ... 
	def writeStr(self, buffer: str) -> bool: ... 


class FileBinary(File):
	seek: int 
	def __init__(self, fileName: str, mode: File.FileMode, throwIncompatibility: bool = True): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 


class FileJson(File):
	seek: int 
	def __init__(self, fileName: str, mode: File.FileMode): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def readStr(self, buffer: str) -> bool: ... 
	def writeStr(self, buffer: str) -> bool: ... 


class FileVirtual(File):
	seek: int 
	def __init__(self, mode: File.FileMode, throwIncompatibility: bool = True, header: bool = True, initialBufferSize: int = 4096): ... 
	def __init__(self, buffer: None, bufferSize: int): ... 
	def __init__(self, other: FileVirtual): ... 
	def getSeek(self) -> int: ... 
	def setSeek(self, value: int) -> None: ... 
	def getSize(self) -> int: ... 
	def read(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def write(self, buffer: None, elementSize: int, elements: int) -> bool: ... 
	def resetMode(self, mode: File.FileMode) -> bool: ... 
	def getUsedSize(self) -> int: ... 


class SceneTimer(Timer):
	"""
	Scene Timer class. Inherits from the Timer class and have the same behavior, except that it won't increment time while the Scene is paused. That's probably the timer you want to use in most cases.
	"""

	def __init__(self): ... 
	def __init__(self, start: float): ... 


class TimedLerp():
	"""
	This class lerps, in a given time in seconds, one value (current) to another (destination). After the lerp is finished, it will always return the destination value.
	"""

	def __init__(self, current: float = 0, destination: float = 1, durationInSeconds: float = 1): ... 
	def __init__(self, other: TimedLerp): ... 
	def get(self) -> float: ... 
	def set(self, current: float, destination: float = 1, durationInSeconds: float = 1) -> None: ... 
	def isFinished(self) -> bool: ... # Checks if the class has finished the lerping process.


class Timer():
	"""
	Timer class that counts elapsed time in seconds. Keep in mind that it keeps counting time even if the scene is paused. If you don't want that, check the SceneTimer instead.
	"""

	def __init__(self): ... 
	def __init__(self, start: float): ... 
	def get(self) -> float: ... # Gets the elapsed time in seconds.
	def set(self, value: float) -> None: ... # Sets the elapsed time to a given amount of seconds and continues to count from that point.
	def reset(self) -> None: ... # Resets the elapsed time to zero and starts counting again.


